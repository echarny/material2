"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = require("typescript");
var LEADING_STAR = /^[^\S\r\n]*\*[^\S\n\r]?/gm;
var ASTERISK = 42;
var SLASH = 47;
function getContent(node) {
    var content = '';
    if (!node)
        return content;
    if (node.kind === typescript_1.SyntaxKind.ModuleDeclaration) {
        var moduleDeclaration = node;
        // If this is left side of dotted module declaration, there is no doc comment associated with this declaration
        if (moduleDeclaration.body && moduleDeclaration.body.kind === typescript_1.SyntaxKind.ModuleDeclaration) {
            return content;
        }
        // If this is dotted module name, get the doc comments from the parent
        while (moduleDeclaration.parent && moduleDeclaration.parent.kind === typescript_1.SyntaxKind.ModuleDeclaration) {
            moduleDeclaration = moduleDeclaration.parent;
        }
        node = moduleDeclaration;
    }
    // If this is a variable declaration then we get the doc comments from the grand parent
    if (node.kind === typescript_1.SyntaxKind.VariableDeclaration) {
        node = node.parent && node.parent.parent || node;
    }
    // Get the source file of this node
    var sourceFile = node.getSourceFile();
    var commentRanges = getJSDocCommentRanges(node, sourceFile.text);
    if (commentRanges) {
        commentRanges.forEach(function (commentRange) {
            content += sourceFile.text
                .substring(commentRange.pos + '/**'.length, commentRange.end - '*/'.length)
                .replace(LEADING_STAR, '')
                .trim();
            if (commentRange.hasTrailingNewLine) {
                content += '\n';
            }
        });
    }
    return content.trim();
}
exports.getContent = getContent;
function getJSDocCommentRanges(node, text) {
    var commentRanges = (node.kind === typescript_1.SyntaxKind.Parameter ||
        node.kind === typescript_1.SyntaxKind.TypeParameter ||
        node.kind === typescript_1.SyntaxKind.FunctionExpression ||
        node.kind === typescript_1.SyntaxKind.ArrowFunction) ?
        concatenate(typescript_1.getTrailingCommentRanges(text, node.pos), typescript_1.getLeadingCommentRanges(text, node.pos)) :
        typescript_1.getLeadingCommentRanges(text, node.pos);
    // True if the comment starts with '/**' but not if it is '/**/'
    if (commentRanges) {
        return commentRanges.filter(function (comment) {
            return text.charCodeAt(comment.pos + 1) === ASTERISK &&
                text.charCodeAt(comment.pos + 2) === ASTERISK &&
                text.charCodeAt(comment.pos + 3) !== SLASH;
        });
    }
}
function concatenate(array1, array2) {
    return array1 ? array2 ? array1.concat(array2) : array1 : array2;
}
//# sourceMappingURL=getContent.js.map