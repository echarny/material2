{"version":3,"file":"tab-group.js","sourceRoot":"","sources":["../../../../src/lib/tabs/tab-group.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAQA,kDAAkF;AAClF,sCAeuB;AACvB,+CAMgC;AAChC,6BAAyC;AACzC,6BAA6B;AAC7B,2CAA0C;;AAI1C,IAAI,MAAM,GAAG,CAAC,CAAC;;AAGf;AAAA;;;4BAzCA;IA8CC,CAAA;AALY,8CAAiB;;;AAY9B;;;AAAA;IACE,yBAAmB,WAAuB;QAAvB,gBAAW,GAAX,WAAW,CAAY;KAAI;0BAtDhD;IAuDC,CAAA;AAFY,0CAAe;AAGf,QAAA,qBAAqB,GAAG,iBAAU,CAAC,yBAAkB,CAAC,eAAe,CAAC,EAAE,SAAS,CAAC;;;;;;;IAsB9D,+BAAqB;IAsEpD,qBAAY,UAAsB,EACd,kBAAqC;QADzD,YAEE,kBAAM,UAAU,CAAC,SAElB;QAHmB,wBAAkB,GAAlB,kBAAkB,CAAmB;;+BA7DjB,CAAC;;sCAGD,CAAC;;kCAGb,mBAAY,CAAC,KAAK;;sCAGd,mBAAY,CAAC,KAAK;+BAMhB,KAAK;+BAQC,IAAI;;+BAGI,OAAO;;oCAmBQ,IAAI,mBAAY,EAAU;;4BAIrF,IAAI,mBAAY,EAAqB;;8BAGc,IAAI,mBAAY,EAAQ;;kCAI3E,IAAI,mBAAY,CAAoB,IAAI,CAAC;QAO3C,KAAI,CAAC,QAAQ,GAAG,MAAM,EAAE,CAAC;;KAC1B;0BAnDG,sCAAa;;sBAAc,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;aAC1D,UAAkB,KAAc,IAAI,IAAI,CAAC,cAAc,GAAG,gCAAqB,CAAC,KAAK,CAAC,CAAC,EAAE;;;;0BAKrF,sCAAa;;sBAAoB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;aAChE,UAAkB,KAAoB;YACpC,IAAI,CAAC,cAAc,GAAG,+BAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;SACzD;;;;0BAQG,wCAAe;;sBAAmB,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;aACnE,UAAoB,KAAmB;YACrC,IAAM,aAAa,GAAgB,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC;YAElE,aAAa,CAAC,SAAS,CAAC,MAAM,CAAC,oBAAkB,IAAI,CAAC,eAAiB,CAAC,CAAC;YAEzE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,aAAa,CAAC,SAAS,CAAC,GAAG,CAAC,oBAAkB,KAAO,CAAC,CAAC;aACxD;YAED,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;SAC/B;;;;IAyBD;;;;;OAKG;;;;;;;IACH,2CAAqB;;;;;;IAArB;QAAA,iBAwCC;;;QArCC,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;;;QAIrF,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,aAAa,CAAC,CAAC,CAAC;YACzC,IAAM,YAAU,GAAG,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC;YAE/C,EAAE,CAAC,CAAC,CAAC,YAAU,CAAC,CAAC,CAAC;gBAChB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC,CAAC;aACrE;;;YAID,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC;gBACrB,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,KAAK,IAAK,OAAA,GAAG,CAAC,QAAQ,GAAG,KAAK,KAAK,aAAa,EAAtC,CAAsC,CAAC,CAAC;gBAE3E,EAAE,CAAC,CAAC,CAAC,YAAU,CAAC,CAAC,CAAC;oBAChB,KAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;iBAC9C;aACF,CAAC,CAAC;SACJ;;QAGD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAC,GAAW,EAAE,KAAa;YAC5C,GAAG,CAAC,QAAQ,GAAG,KAAK,GAAG,aAAa,CAAC;;;YAIrC,EAAE,CAAC,CAAC,KAAI,CAAC,cAAc,IAAI,IAAI,IAAI,GAAG,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;gBACpE,GAAG,CAAC,MAAM,GAAG,aAAa,GAAG,KAAI,CAAC,cAAc,CAAC;aAClD;SACF,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,KAAK,aAAa,CAAC,CAAC,CAAC;YAC1C,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;YACpC,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,CAAC;SACxC;KACF;IAED,wCAAkB,GAAlB;QAAA,iBA2BC;QA1BC,IAAI,CAAC,qBAAqB,EAAE,CAAC;;;QAI7B,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;YACpD,IAAM,aAAa,GAAG,KAAI,CAAC,cAAc,CAAC,KAAI,CAAC,cAAc,CAAC,CAAC;;;YAI/D,EAAE,CAAC,CAAC,aAAa,KAAK,KAAI,CAAC,cAAc,CAAC,CAAC,CAAC;gBAC1C,IAAM,IAAI,GAAG,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;gBAElC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACrC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;;;;wBAIrB,AAHA,sFAAsF;wBACtF,uFAAuF;wBACvF,uDAAuD;wBACvD,KAAI,CAAC,cAAc,GAAG,KAAI,CAAC,cAAc,GAAG,CAAC,CAAC;wBAC9C,KAAK,CAAC;qBACP;iBACF;aACF;YAED,KAAI,CAAC,qBAAqB,EAAE,CAAC;YAC7B,KAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,CAAC;SACxC,CAAC,CAAC;KACJ;IAED,iCAAW,GAAX;QACE,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,CAAC;QACrC,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,CAAC;KAC1C;IAED,yDAAyD;;IACzD,mCAAa;IAAb;QACE,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,UAAU,CAAC,yBAAyB,EAAE,CAAC;SAC7C;KACF;IAED,mCAAa,GAAb,UAAc,KAAa;QACzB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;KACvD;IAEO,wCAAkB,GAA1B,UAA2B,KAAa;QACtC,IAAM,KAAK,GAAG,IAAI,iBAAiB,CAAC;QACpC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC;QACpB,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YACpC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;SACzC;QACD,MAAM,CAAC,KAAK,CAAC;KACd;IAED;;;;;OAKG;;;;;;;IACK,2CAAqB;;;;;;IAA7B;QAAA,iBAOC;QANC,EAAE,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC;YAC/B,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,CAAC;SAC1C;QAED,IAAI,CAAC,qBAAqB,GAAG,YAAK,eAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,aAAa,EAAjB,CAAiB,CAAC,EAC3E,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,EAAtC,CAAsC,CAAC,CAAC;KAC5D;IAED,qEAAqE;;IAC7D,oCAAc;IAAtB,UAAuB,KAAoB;;;;QAIzC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;KACjE;IAED,qDAAqD;;IACrD,oCAAc;IAAd,UAAe,CAAS;QACtB,MAAM,CAAC,mBAAiB,IAAI,CAAC,QAAQ,SAAI,CAAG,CAAC;KAC9C;IAED,uDAAuD;;IACvD,sCAAgB;IAAhB,UAAiB,CAAS;QACxB,MAAM,CAAC,qBAAmB,IAAI,CAAC,QAAQ,SAAI,CAAG,CAAC;KAChD;IAED;;;OAGG;;;;;IACH,8CAAwB;;;;IAAxB,UAAyB,SAAiB;QACxC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC;SAAE;QAEpE,IAAM,OAAO,GAAgB,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC;QAEhE,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;;;QAIzD,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC;YACpD,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,GAAG,IAAI,CAAC;SACzC;KACF;IAED,kDAAkD;;IAClD,iDAA2B;IAA3B;QACE,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,YAAY,CAAC;QAC7E,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,GAAG,EAAE,CAAC;QACrD,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;KAC3B;IAED,sEAAsE;;IACtE,kCAAY;IAAZ,UAAa,GAAW,EAAE,SAAuB,EAAE,GAAW;QAC5D,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,UAAU,GAAG,GAAG,CAAC;SACjD;KACF;IAED,0CAA0C;;IAC1C,kCAAY;IAAZ,UAAa,GAAW,EAAE,GAAW;QACnC,EAAE,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;YACjB,MAAM,CAAC,IAAI,CAAC;SACb;QACD,MAAM,CAAC,IAAI,CAAC,aAAa,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC5C;;gBAxQF,gBAAS,SAAC;oBACT,QAAQ,EAAE,MAAM,CAAC,EAAE;oBACnB,QAAQ,EAAE,eAAe;oBACzB,QAAQ,EAAE,aAAa;oBACvB,WAAW,EAAE,gBAAgB;oBAC7B,SAAS,EAAE,CAAC,eAAe,CAAC;oBAC5B,aAAa,EAAE,wBAAiB,CAAC,IAAI;oBACrC,eAAe,EAAE,8BAAuB,CAAC,MAAM;oBAC/C,MAAM,EAAE,CAAC,OAAO,EAAE,eAAe,CAAC;oBAClC,IAAI,EAAE;wBACJ,OAAO,EAAE,eAAe;wBACxB,sCAAsC,EAAE,eAAe;wBACvD,uCAAuC,EAAE,4BAA4B;qBACtE;iBACF;;;;gBA7DC,iBAAU;gBAHV,wBAAiB;;;0BAoEhB,sBAAe,SAAC,YAAM;oCAEtB,gBAAS,SAAC,gBAAgB;+BAE1B,gBAAS,SAAC,WAAW;kCAerB,YAAK;kCAML,YAAK;mCAQL,YAAK;oCAGL,YAAK;wCAgBL,aAAM;gCAGN,aAAM;kCAIN,aAAM;sCAGN,aAAM;;sBA/IT;EA8EiC,6BAAqB;AAAzC,kCAAW","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\r\nimport {\r\n  AfterContentChecked,\r\n  AfterContentInit,\r\n  ChangeDetectionStrategy,\r\n  ChangeDetectorRef,\r\n  Component,\r\n  ContentChildren,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Input,\r\n  OnDestroy,\r\n  Output,\r\n  QueryList,\r\n  ViewChild,\r\n  ViewEncapsulation,\r\n} from '@angular/core';\r\nimport {\r\n  CanColor,\r\n  CanDisableRipple,\r\n  mixinColor,\r\n  mixinDisableRipple,\r\n  ThemePalette\r\n} from '@angular/material/core';\r\nimport {merge, Subscription} from 'rxjs';\r\nimport {MatTab} from './tab';\r\nimport {MatTabHeader} from './tab-header';\r\n\r\n\r\n/** Used to generate unique ID's for each tab component */\r\nlet nextId = 0;\r\n\r\n/** A simple change event emitted on focus or selection changes. */\r\nexport class MatTabChangeEvent {\r\n  /** Index of the currently-selected tab. */\r\n  index: number;\r\n  /** Reference to the currently-selected tab. */\r\n  tab: MatTab;\r\n}\r\n\r\n/** Possible positions for the tab header. */\r\nexport type MatTabHeaderPosition = 'above' | 'below';\r\n\r\n// Boilerplate for applying mixins to MatTabGroup.\r\n/** @docs-private */\r\nexport class MatTabGroupBase {\r\n  constructor(public _elementRef: ElementRef) {}\r\n}\r\nexport const _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');\r\n\r\n/**\r\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\r\n * animated ink-bar, keyboard navigation, and screen reader.\r\n * See: https://material.io/design/components/tabs.html\r\n */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'mat-tab-group',\r\n  exportAs: 'matTabGroup',\r\n  templateUrl: 'tab-group.html',\r\n  styleUrls: ['tab-group.css'],\r\n  encapsulation: ViewEncapsulation.None,\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  inputs: ['color', 'disableRipple'],\r\n  host: {\r\n    'class': 'mat-tab-group',\r\n    '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\r\n    '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"',\r\n  },\r\n})\r\nexport class MatTabGroup extends _MatTabGroupMixinBase implements AfterContentInit,\r\n    AfterContentChecked, OnDestroy, CanColor, CanDisableRipple {\r\n\r\n  @ContentChildren(MatTab) _tabs: QueryList<MatTab>;\r\n\r\n  @ViewChild('tabBodyWrapper') _tabBodyWrapper: ElementRef;\r\n\r\n  @ViewChild('tabHeader') _tabHeader: MatTabHeader;\r\n\r\n  /** The tab index that should be selected after the content has been checked. */\r\n  private _indexToSelect: number | null = 0;\r\n\r\n  /** Snapshot of the height of the tab body wrapper before another tab is activated. */\r\n  private _tabBodyWrapperHeight: number = 0;\r\n\r\n  /** Subscription to tabs being added/removed. */\r\n  private _tabsSubscription = Subscription.EMPTY;\r\n\r\n  /** Subscription to changes in the tab labels. */\r\n  private _tabLabelSubscription = Subscription.EMPTY;\r\n\r\n  /** Whether the tab group should grow to the size of the active tab. */\r\n  @Input()\r\n  get dynamicHeight(): boolean { return this._dynamicHeight; }\r\n  set dynamicHeight(value: boolean) { this._dynamicHeight = coerceBooleanProperty(value); }\r\n  private _dynamicHeight: boolean = false;\r\n\r\n  /** The index of the active tab. */\r\n  @Input()\r\n  get selectedIndex(): number | null { return this._selectedIndex; }\r\n  set selectedIndex(value: number | null) {\r\n    this._indexToSelect = coerceNumberProperty(value, null);\r\n  }\r\n  private _selectedIndex: number | null = null;\r\n\r\n  /** Position of the tab header. */\r\n  @Input() headerPosition: MatTabHeaderPosition = 'above';\r\n\r\n  /** Background color of the tab group. */\r\n  @Input()\r\n  get backgroundColor(): ThemePalette { return this._backgroundColor; }\r\n  set backgroundColor(value: ThemePalette) {\r\n    const nativeElement: HTMLElement = this._elementRef.nativeElement;\r\n\r\n    nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\r\n\r\n    if (value) {\r\n      nativeElement.classList.add(`mat-background-${value}`);\r\n    }\r\n\r\n    this._backgroundColor = value;\r\n  }\r\n  private _backgroundColor: ThemePalette;\r\n\r\n  /** Output to enable support for two-way binding on `[(selectedIndex)]` */\r\n  @Output() readonly selectedIndexChange: EventEmitter<number> = new EventEmitter<number>();\r\n\r\n  /** Event emitted when focus has changed within a tab group. */\r\n  @Output() readonly focusChange: EventEmitter<MatTabChangeEvent> =\r\n      new EventEmitter<MatTabChangeEvent>();\r\n\r\n  /** Event emitted when the body animation has completed */\r\n  @Output() readonly animationDone: EventEmitter<void> = new EventEmitter<void>();\r\n\r\n  /** Event emitted when the tab selection has changed. */\r\n  @Output() readonly selectedTabChange: EventEmitter<MatTabChangeEvent> =\r\n      new EventEmitter<MatTabChangeEvent>(true);\r\n\r\n  private _groupId: number;\r\n\r\n  constructor(elementRef: ElementRef,\r\n              private _changeDetectorRef: ChangeDetectorRef) {\r\n    super(elementRef);\r\n    this._groupId = nextId++;\r\n  }\r\n\r\n  /**\r\n   * After the content is checked, this component knows what tabs have been defined\r\n   * and what the selected index should be. This is where we can know exactly what position\r\n   * each tab should be in according to the new selected index, and additionally we know how\r\n   * a new selected tab should transition in (from the left or right).\r\n   */\r\n  ngAfterContentChecked() {\r\n    // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\r\n    // the amount of tabs changes before the actual change detection runs.\r\n    const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\r\n\r\n    // If there is a change in selected index, emit a change event. Should not trigger if\r\n    // the selected index has not yet been initialized.\r\n    if (this._selectedIndex != indexToSelect) {\r\n      const isFirstRun = this._selectedIndex == null;\r\n\r\n      if (!isFirstRun) {\r\n        this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\r\n      }\r\n\r\n      // Changing these values after change detection has run\r\n      // since the checked content may contain references to them.\r\n      Promise.resolve().then(() => {\r\n        this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\r\n\r\n        if (!isFirstRun) {\r\n          this.selectedIndexChange.emit(indexToSelect);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Setup the position for each tab and optionally setup an origin on the next selected tab.\r\n    this._tabs.forEach((tab: MatTab, index: number) => {\r\n      tab.position = index - indexToSelect;\r\n\r\n      // If there is already a selected tab, then set up an origin for the next selected tab\r\n      // if it doesn't have one already.\r\n      if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\r\n        tab.origin = indexToSelect - this._selectedIndex;\r\n      }\r\n    });\r\n\r\n    if (this._selectedIndex !== indexToSelect) {\r\n      this._selectedIndex = indexToSelect;\r\n      this._changeDetectorRef.markForCheck();\r\n    }\r\n  }\r\n\r\n  ngAfterContentInit() {\r\n    this._subscribeToTabLabels();\r\n\r\n    // Subscribe to changes in the amount of tabs, in order to be\r\n    // able to re-render the content as new tabs are added or removed.\r\n    this._tabsSubscription = this._tabs.changes.subscribe(() => {\r\n      const indexToSelect = this._clampTabIndex(this._indexToSelect);\r\n\r\n      // Maintain the previously-selected tab if a new tab is added or removed and there is no\r\n      // explicit change that selects a different tab.\r\n      if (indexToSelect === this._selectedIndex) {\r\n        const tabs = this._tabs.toArray();\r\n\r\n        for (let i = 0; i < tabs.length; i++) {\r\n          if (tabs[i].isActive) {\r\n            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\r\n            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\r\n            // adding a tab within the `selectedIndexChange` event.\r\n            this._indexToSelect = this._selectedIndex = i;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      this._subscribeToTabLabels();\r\n      this._changeDetectorRef.markForCheck();\r\n    });\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._tabsSubscription.unsubscribe();\r\n    this._tabLabelSubscription.unsubscribe();\r\n  }\r\n\r\n  /** Re-aligns the ink bar to the selected tab element. */\r\n  realignInkBar() {\r\n    if (this._tabHeader) {\r\n      this._tabHeader._alignInkBarToSelectedTab();\r\n    }\r\n  }\r\n\r\n  _focusChanged(index: number) {\r\n    this.focusChange.emit(this._createChangeEvent(index));\r\n  }\r\n\r\n  private _createChangeEvent(index: number): MatTabChangeEvent {\r\n    const event = new MatTabChangeEvent;\r\n    event.index = index;\r\n    if (this._tabs && this._tabs.length) {\r\n      event.tab = this._tabs.toArray()[index];\r\n    }\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\r\n   * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\r\n   * binding to be updated, we need to subscribe to changes in it and trigger change detection\r\n   * manually.\r\n   */\r\n  private _subscribeToTabLabels() {\r\n    if (this._tabLabelSubscription) {\r\n      this._tabLabelSubscription.unsubscribe();\r\n    }\r\n\r\n    this._tabLabelSubscription = merge(...this._tabs.map(tab => tab._stateChanges))\r\n      .subscribe(() => this._changeDetectorRef.markForCheck());\r\n  }\r\n\r\n  /** Clamps the given index to the bounds of 0 and the tabs length. */\r\n  private _clampTabIndex(index: number | null): number {\r\n    // Note the `|| 0`, which ensures that values like NaN can't get through\r\n    // and which would otherwise throw the component into an infinite loop\r\n    // (since Math.max(NaN, 0) === NaN).\r\n    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\r\n  }\r\n\r\n  /** Returns a unique id for each tab label element */\r\n  _getTabLabelId(i: number): string {\r\n    return `mat-tab-label-${this._groupId}-${i}`;\r\n  }\r\n\r\n  /** Returns a unique id for each tab content element */\r\n  _getTabContentId(i: number): string {\r\n    return `mat-tab-content-${this._groupId}-${i}`;\r\n  }\r\n\r\n  /**\r\n   * Sets the height of the body wrapper to the height of the activating tab if dynamic\r\n   * height property is true.\r\n   */\r\n  _setTabBodyWrapperHeight(tabHeight: number): void {\r\n    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) { return; }\r\n\r\n    const wrapper: HTMLElement = this._tabBodyWrapper.nativeElement;\r\n\r\n    wrapper.style.height = this._tabBodyWrapperHeight + 'px';\r\n\r\n    // This conditional forces the browser to paint the height so that\r\n    // the animation to the new height can have an origin.\r\n    if (this._tabBodyWrapper.nativeElement.offsetHeight) {\r\n      wrapper.style.height = tabHeight + 'px';\r\n    }\r\n  }\r\n\r\n  /** Removes the height of the tab body wrapper. */\r\n  _removeTabBodyWrapperHeight(): void {\r\n    this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\r\n    this._tabBodyWrapper.nativeElement.style.height = '';\r\n    this.animationDone.emit();\r\n  }\r\n\r\n  /** Handle click events, setting new selected index if appropriate. */\r\n  _handleClick(tab: MatTab, tabHeader: MatTabHeader, idx: number) {\r\n    if (!tab.disabled) {\r\n      this.selectedIndex = tabHeader.focusIndex = idx;\r\n    }\r\n  }\r\n\r\n  /** Retrieves the tabindex for the tab. */\r\n  _getTabIndex(tab: MatTab, idx: number): number | null {\r\n    if (tab.disabled) {\r\n      return null;\r\n    }\r\n    return this.selectedIndex === idx ? 0 : -1;\r\n  }\r\n}\r\n"]}