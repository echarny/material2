{"version":3,"file":"drawer.js","sourceRoot":"","sources":["../../../../src/lib/sidenav/drawer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport {AnimationEvent} from '@angular/animations';\r\nimport {FocusMonitor, FocusOrigin, FocusTrap, FocusTrapFactory} from '@angular/cdk/a11y';\r\nimport {Directionality} from '@angular/cdk/bidi';\r\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\r\nimport {ESCAPE} from '@angular/cdk/keycodes';\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {CdkScrollable, ScrollDispatcher} from '@angular/cdk/scrolling';\r\nimport {DOCUMENT} from '@angular/common';\r\nimport {\r\n  AfterContentChecked,\r\n  AfterContentInit,\r\n  ChangeDetectionStrategy,\r\n  ChangeDetectorRef,\r\n  Component,\r\n  ContentChild,\r\n  ContentChildren,\r\n  DoCheck,\r\n  ElementRef,\r\n  EventEmitter,\r\n  forwardRef,\r\n  Inject,\r\n  InjectionToken,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  QueryList,\r\n  ViewChild,\r\n  ViewEncapsulation,\r\n} from '@angular/core';\r\nimport {fromEvent, merge, Observable, Subject} from 'rxjs';\r\nimport {debounceTime, filter, map, startWith, take, takeUntil} from 'rxjs/operators';\r\nimport {matDrawerAnimations} from './drawer-animations';\r\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\r\n\r\n\r\n/** Throws an exception when two MatDrawer are matching the same position. */\r\nexport function throwMatDuplicatedDrawerError(position: string) {\r\n  throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\r\n}\r\n\r\n\r\n/** Result of the toggle promise that indicates the state of the drawer. */\r\nexport type MatDrawerToggleResult = 'open' | 'close';\r\n\r\n/** Configures whether drawers should use auto sizing by default. */\r\nexport const MAT_DRAWER_DEFAULT_AUTOSIZE =\r\n    new InjectionToken<boolean>('MAT_DRAWER_DEFAULT_AUTOSIZE', {\r\n      providedIn: 'root',\r\n      factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\r\n    });\r\n\r\n/** @docs-private */\r\nexport function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY(): boolean {\r\n  return false;\r\n}\r\n\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'mat-drawer-content',\r\n  template: '<ng-content></ng-content>',\r\n  host: {\r\n    'class': 'mat-drawer-content',\r\n    '[style.margin-left.px]': '_container._contentMargins.left',\r\n    '[style.margin-right.px]': '_container._contentMargins.right',\r\n  },\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  encapsulation: ViewEncapsulation.None,\r\n})\r\nexport class MatDrawerContent extends CdkScrollable implements AfterContentInit {\r\n  constructor(\r\n      private _changeDetectorRef: ChangeDetectorRef,\r\n      @Inject(forwardRef(() => MatDrawerContainer)) public _container: MatDrawerContainer,\r\n      elementRef: ElementRef<HTMLElement>,\r\n      scrollDispatcher: ScrollDispatcher,\r\n      ngZone: NgZone) {\r\n    super(elementRef, scrollDispatcher, ngZone);\r\n  }\r\n\r\n  ngAfterContentInit() {\r\n    this._container._contentMarginChanges.subscribe(() => {\r\n      this._changeDetectorRef.markForCheck();\r\n    });\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * This component corresponds to a drawer that can be opened on the drawer container.\r\n */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'mat-drawer',\r\n  exportAs: 'matDrawer',\r\n  template: '<ng-content></ng-content>',\r\n  animations: [matDrawerAnimations.transformDrawer],\r\n  host: {\r\n    'class': 'mat-drawer',\r\n    '[@transform]': '_animationState',\r\n    '(@transform.start)': '_onAnimationStart($event)',\r\n    '(@transform.done)': '_onAnimationEnd($event)',\r\n    // must prevent the browser from aligning text based on value\r\n    '[attr.align]': 'null',\r\n    '[class.mat-drawer-end]': 'position === \"end\"',\r\n    '[class.mat-drawer-over]': 'mode === \"over\"',\r\n    '[class.mat-drawer-push]': 'mode === \"push\"',\r\n    '[class.mat-drawer-side]': 'mode === \"side\"',\r\n    'tabIndex': '-1',\r\n  },\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  encapsulation: ViewEncapsulation.None,\r\n})\r\nexport class MatDrawer implements AfterContentInit, AfterContentChecked, OnDestroy {\r\n  private _focusTrap: FocusTrap;\r\n  private _elementFocusedBeforeDrawerWasOpened: HTMLElement | null = null;\r\n\r\n  /** Whether the drawer is initialized. Used for disabling the initial animation. */\r\n  private _enableAnimations = false;\r\n\r\n  /** The side that the drawer is attached to. */\r\n  @Input()\r\n  get position(): 'start' | 'end' { return this._position; }\r\n  set position(value: 'start' | 'end') {\r\n    // Make sure we have a valid value.\r\n    value = value === 'end' ? 'end' : 'start';\r\n    if (value != this._position) {\r\n      this._position = value;\r\n      this.onPositionChanged.emit();\r\n    }\r\n  }\r\n  private _position: 'start' | 'end' = 'start';\r\n\r\n  /** Mode of the drawer; one of 'over', 'push' or 'side'. */\r\n  @Input()\r\n  get mode(): 'over' | 'push' | 'side' { return this._mode; }\r\n  set mode(value: 'over' | 'push' | 'side') {\r\n    this._mode = value;\r\n    this._modeChanged.next();\r\n  }\r\n  private _mode: 'over' | 'push' | 'side' = 'over';\r\n\r\n  /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\r\n  @Input()\r\n  get disableClose(): boolean { return this._disableClose; }\r\n  set disableClose(value: boolean) { this._disableClose = coerceBooleanProperty(value); }\r\n  private _disableClose: boolean = false;\r\n\r\n  /** Whether the drawer should focus the first focusable element automatically when opened. */\r\n  @Input()\r\n  get autoFocus(): boolean { return this._autoFocus; }\r\n  set autoFocus(value: boolean) { this._autoFocus = coerceBooleanProperty(value); }\r\n  private _autoFocus: boolean = true;\r\n\r\n  /** How the sidenav was opened (keypress, mouse click etc.) */\r\n  private _openedVia: FocusOrigin | null;\r\n\r\n  /** Emits whenever the drawer has started animating. */\r\n  _animationStarted = new EventEmitter<AnimationEvent>();\r\n\r\n  /** Current state of the sidenav animation. */\r\n  _animationState: 'open-instant' | 'open' | 'void' = 'void';\r\n\r\n  /** Event emitted when the drawer open state is changed. */\r\n  @Output() readonly openedChange: EventEmitter<boolean> =\r\n      // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\r\n      new EventEmitter<boolean>(/* isAsync */true);\r\n\r\n  /** Event emitted when the drawer has been opened. */\r\n  @Output('opened')\r\n  get _openedStream(): Observable<void> {\r\n    return this.openedChange.pipe(filter(o => o), map(() => {}));\r\n  }\r\n\r\n  /** Event emitted when the drawer has started opening. */\r\n  @Output()\r\n  get openedStart(): Observable<void> {\r\n    return this._animationStarted.pipe(\r\n      filter(e => e.fromState !== e.toState && e.toState.indexOf('open') === 0),\r\n      map(() => {})\r\n    );\r\n  }\r\n\r\n  /** Event emitted when the drawer has been closed. */\r\n  @Output('closed')\r\n  get _closedStream(): Observable<void> {\r\n    return this.openedChange.pipe(filter(o => !o), map(() => {}));\r\n  }\r\n\r\n  /** Event emitted when the drawer has started closing. */\r\n  @Output()\r\n  get closedStart(): Observable<void> {\r\n    return this._animationStarted.pipe(\r\n      filter(e => e.fromState !== e.toState && e.toState === 'void'),\r\n      map(() => {})\r\n    );\r\n  }\r\n\r\n  /** Event emitted when the drawer's position changes. */\r\n  // tslint:disable-next-line:no-output-on-prefix\r\n  @Output('positionChanged') onPositionChanged: EventEmitter<void> = new EventEmitter<void>();\r\n\r\n  /**\r\n   * An observable that emits when the drawer mode changes. This is used by the drawer container to\r\n   * to know when to when the mode changes so it can adapt the margins on the content.\r\n   */\r\n  readonly _modeChanged = new Subject();\r\n\r\n  get _isFocusTrapEnabled(): boolean {\r\n    // The focus trap is only enabled when the drawer is open in any mode other than side.\r\n    return this.opened && this.mode !== 'side';\r\n  }\r\n\r\n  constructor(private _elementRef: ElementRef,\r\n              private _focusTrapFactory: FocusTrapFactory,\r\n              private _focusMonitor: FocusMonitor,\r\n              private _platform: Platform,\r\n              private _ngZone: NgZone,\r\n              @Optional() @Inject(DOCUMENT) private _doc: any) {\r\n\r\n    this.openedChange.subscribe((opened: boolean) => {\r\n      if (opened) {\r\n        if (this._doc) {\r\n          this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement as HTMLElement;\r\n        }\r\n\r\n        if (this._isFocusTrapEnabled && this._focusTrap) {\r\n          this._trapFocus();\r\n        }\r\n      } else {\r\n        this._restoreFocus();\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Listen to `keydown` events outside the zone so that change detection is not run every\r\n     * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\r\n     * and we don't have close disabled.\r\n     */\r\n    this._ngZone.runOutsideAngular(() => {\r\n        fromEvent(this._elementRef.nativeElement, 'keydown').pipe(\r\n            filter((event: KeyboardEvent) => event.keyCode === ESCAPE && !this.disableClose)\r\n        ).subscribe((event) => this._ngZone.run(() => {\r\n            this.close();\r\n            event.stopPropagation();\r\n        }));\r\n    });\r\n  }\r\n\r\n  /** Traps focus inside the drawer. */\r\n  private _trapFocus() {\r\n    if (!this.autoFocus) {\r\n      return;\r\n    }\r\n\r\n    this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {\r\n      // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\r\n      // still works. We need to check that `focus` is a function due to Universal.\r\n      if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\r\n        this._elementRef.nativeElement.focus();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * If focus is currently inside the drawer, restores it to where it was before the drawer\r\n   * opened.\r\n   */\r\n  private _restoreFocus() {\r\n    if (!this.autoFocus) {\r\n      return;\r\n    }\r\n\r\n    const activeEl = this._doc && this._doc.activeElement;\r\n\r\n    if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\r\n      if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {\r\n        this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\r\n      } else {\r\n        this._elementRef.nativeElement.blur();\r\n      }\r\n    }\r\n\r\n    this._elementFocusedBeforeDrawerWasOpened = null;\r\n    this._openedVia = null;\r\n  }\r\n\r\n  ngAfterContentInit() {\r\n    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\r\n    this._focusTrap.enabled = this._isFocusTrapEnabled;\r\n  }\r\n\r\n  ngAfterContentChecked() {\r\n    // Enable the animations after the lifecycle hooks have run, in order to avoid animating\r\n    // drawers that are open by default. When we're on the server, we shouldn't enable the\r\n    // animations, because we don't want the drawer to animate the first time the user sees\r\n    // the page.\r\n    if (this._platform.isBrowser) {\r\n      this._enableAnimations = true;\r\n    }\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    if (this._focusTrap) {\r\n      this._focusTrap.destroy();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether the drawer is opened. We overload this because we trigger an event when it\r\n   * starts or end.\r\n   */\r\n  @Input()\r\n  get opened(): boolean { return this._opened; }\r\n  set opened(value: boolean) { this.toggle(coerceBooleanProperty(value)); }\r\n  private _opened: boolean = false;\r\n\r\n  /**\r\n   * Open the drawer.\r\n   * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n   * Used for focus management after the sidenav is closed.\r\n   */\r\n  open(openedVia?: FocusOrigin): Promise<MatDrawerToggleResult> {\r\n    return this.toggle(true, openedVia);\r\n  }\r\n\r\n  /** Close the drawer. */\r\n  close(): Promise<MatDrawerToggleResult> {\r\n    return this.toggle(false);\r\n  }\r\n\r\n  /**\r\n   * Toggle this drawer.\r\n   * @param isOpen Whether the drawer should be open.\r\n   * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n   * Used for focus management after the sidenav is closed.\r\n   */\r\n  toggle(isOpen: boolean = !this.opened, openedVia: FocusOrigin = 'program'):\r\n    Promise<MatDrawerToggleResult> {\r\n\r\n    this._opened = isOpen;\r\n\r\n    if (isOpen) {\r\n      this._animationState = this._enableAnimations ? 'open' : 'open-instant';\r\n      this._openedVia = openedVia;\r\n    } else {\r\n      this._animationState = 'void';\r\n      this._restoreFocus();\r\n    }\r\n\r\n    if (this._focusTrap) {\r\n      this._focusTrap.enabled = this._isFocusTrapEnabled;\r\n    }\r\n\r\n    return new Promise<MatDrawerToggleResult>(resolve => {\r\n      this.openedChange.pipe(take(1)).subscribe(open => resolve(open ? 'open' : 'close'));\r\n    });\r\n  }\r\n\r\n  _onAnimationStart(event: AnimationEvent) {\r\n    this._animationStarted.emit(event);\r\n  }\r\n\r\n  _onAnimationEnd(event: AnimationEvent) {\r\n    const {fromState, toState} = event;\r\n\r\n    if ((toState.indexOf('open') === 0 && fromState === 'void') ||\r\n        (toState === 'void' && fromState.indexOf('open') === 0)) {\r\n      this.openedChange.emit(this._opened);\r\n    }\r\n  }\r\n\r\n  get _width(): number {\r\n    return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * `<mat-drawer-container>` component.\r\n *\r\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\r\n * and coordinates the backdrop and content styling.\r\n */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'mat-drawer-container',\r\n  exportAs: 'matDrawerContainer',\r\n  templateUrl: 'drawer-container.html',\r\n  styleUrls: ['drawer.css'],\r\n  host: {\r\n    'class': 'mat-drawer-container',\r\n    '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\r\n  },\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  encapsulation: ViewEncapsulation.None,\r\n})\r\nexport class MatDrawerContainer implements AfterContentInit, DoCheck, OnDestroy {\r\n  @ContentChildren(MatDrawer) _drawers: QueryList<MatDrawer>;\r\n  @ContentChild(MatDrawerContent) _content: MatDrawerContent;\r\n  @ViewChild(MatDrawerContent) _userContent: MatDrawerContent;\r\n\r\n  /** The drawer child with the `start` position. */\r\n  get start(): MatDrawer | null { return this._start; }\r\n\r\n  /** The drawer child with the `end` position. */\r\n  get end(): MatDrawer | null { return this._end; }\r\n\r\n  /**\r\n   * Whether to automatically resize the container whenever\r\n   * the size of any of its drawers changes.\r\n   *\r\n   * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\r\n   * the drawers on every change detection cycle. Can be configured globally via the\r\n   * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\r\n   */\r\n  @Input()\r\n  get autosize(): boolean { return this._autosize; }\r\n  set autosize(value: boolean) { this._autosize = coerceBooleanProperty(value); }\r\n  private _autosize: boolean;\r\n\r\n  /**\r\n   * Whether the drawer container should have a backdrop while one of the sidenavs is open.\r\n   * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\r\n   * mode as well.\r\n   */\r\n  @Input()\r\n  get hasBackdrop() {\r\n    if (this._backdropOverride == null) {\r\n      return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';\r\n    }\r\n\r\n    return this._backdropOverride;\r\n  }\r\n  set hasBackdrop(value: any) {\r\n    this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\r\n  }\r\n  _backdropOverride: boolean | null;\r\n\r\n  /** Event emitted when the drawer backdrop is clicked. */\r\n  @Output() readonly backdropClick: EventEmitter<void> = new EventEmitter<void>();\r\n\r\n  /** The drawer at the start/end position, independent of direction. */\r\n  private _start: MatDrawer | null;\r\n  private _end: MatDrawer | null;\r\n\r\n  /**\r\n   * The drawer at the left/right. When direction changes, these will change as well.\r\n   * They're used as aliases for the above to set the left/right style properly.\r\n   * In LTR, _left == _start and _right == _end.\r\n   * In RTL, _left == _end and _right == _start.\r\n   */\r\n  private _left: MatDrawer | null;\r\n  private _right: MatDrawer | null;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  private readonly _destroyed = new Subject<void>();\r\n\r\n  /** Emits on every ngDoCheck. Used for debouncing reflows. */\r\n  private readonly _doCheckSubject = new Subject<void>();\r\n\r\n  /**\r\n   * Margins to be applied to the content. These are used to push / shrink the drawer content when a\r\n   * drawer is open. We use margin rather than transform even for push mode because transform breaks\r\n   * fixed position elements inside of the transformed element.\r\n   */\r\n  _contentMargins: {left: number|null, right: number|null} = {left: null, right: null};\r\n\r\n  readonly _contentMarginChanges = new Subject<{left: number|null, right: number|null}>();\r\n\r\n  /** Reference to the CdkScrollable instance that wraps the scrollable content. */\r\n  get scrollable(): CdkScrollable {\r\n    return this._userContent || this._content;\r\n  }\r\n\r\n  constructor(@Optional() private _dir: Directionality,\r\n              private _element: ElementRef,\r\n              private _ngZone: NgZone,\r\n              private _changeDetectorRef: ChangeDetectorRef,\r\n              @Inject(MAT_DRAWER_DEFAULT_AUTOSIZE) defaultAutosize = false,\r\n              @Optional() @Inject(ANIMATION_MODULE_TYPE) private _animationMode?: string) {\r\n\r\n    // If a `Dir` directive exists up the tree, listen direction changes\r\n    // and update the left/right properties to point to the proper start/end.\r\n    if (_dir) {\r\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\r\n        this._validateDrawers();\r\n        this._updateContentMargins();\r\n      });\r\n    }\r\n\r\n    this._autosize = defaultAutosize;\r\n  }\r\n\r\n  ngAfterContentInit() {\r\n    this._drawers.changes.pipe(startWith(null)).subscribe(() => {\r\n      this._validateDrawers();\r\n\r\n      this._drawers.forEach((drawer: MatDrawer) => {\r\n        this._watchDrawerToggle(drawer);\r\n        this._watchDrawerPosition(drawer);\r\n        this._watchDrawerMode(drawer);\r\n      });\r\n\r\n      if (!this._drawers.length ||\r\n          this._isDrawerOpen(this._start) ||\r\n          this._isDrawerOpen(this._end)) {\r\n        this._updateContentMargins();\r\n      }\r\n\r\n      this._changeDetectorRef.markForCheck();\r\n    });\r\n\r\n    this._doCheckSubject.pipe(\r\n      debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps\r\n      takeUntil(this._destroyed)\r\n    ).subscribe(() => this._updateContentMargins());\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._doCheckSubject.complete();\r\n    this._destroyed.next();\r\n    this._destroyed.complete();\r\n  }\r\n\r\n  /** Calls `open` of both start and end drawers */\r\n  open(): void {\r\n    this._drawers.forEach(drawer => drawer.open());\r\n  }\r\n\r\n  /** Calls `close` of both start and end drawers */\r\n  close(): void {\r\n    this._drawers.forEach(drawer => drawer.close());\r\n  }\r\n\r\n  ngDoCheck() {\r\n    // If users opted into autosizing, do a check every change detection cycle.\r\n    if (this._autosize && this._isPushed()) {\r\n      // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\r\n      this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribes to drawer events in order to set a class on the main container element when the\r\n   * drawer is open and the backdrop is visible. This ensures any overflow on the container element\r\n   * is properly hidden.\r\n   */\r\n  private _watchDrawerToggle(drawer: MatDrawer): void {\r\n    drawer._animationStarted.pipe(\r\n      takeUntil(this._drawers.changes),\r\n      filter((event: AnimationEvent) => event.fromState !== event.toState)\r\n    )\r\n    .subscribe((event: AnimationEvent) => {\r\n      // Set the transition class on the container so that the animations occur. This should not\r\n      // be set initially because animations should only be triggered via a change in state.\r\n      if (event.toState !== 'open-instant' && this._animationMode !== 'NoopAnimations') {\r\n        this._element.nativeElement.classList.add('mat-drawer-transition');\r\n      }\r\n\r\n      this._updateContentMargins();\r\n      this._changeDetectorRef.markForCheck();\r\n    });\r\n\r\n    if (drawer.mode !== 'side') {\r\n      drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(() =>\r\n          this._setContainerClass(drawer.opened));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribes to drawer onPositionChanged event in order to\r\n   * re-validate drawers when the position changes.\r\n   */\r\n  private _watchDrawerPosition(drawer: MatDrawer): void {\r\n    if (!drawer) {\r\n      return;\r\n    }\r\n    // NOTE: We need to wait for the microtask queue to be empty before validating,\r\n    // since both drawers may be swapping positions at the same time.\r\n    drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\r\n      this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(() => {\r\n        this._validateDrawers();\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Subscribes to changes in drawer mode so we can run change detection. */\r\n  private _watchDrawerMode(drawer: MatDrawer): void {\r\n    if (drawer) {\r\n      drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed)))\r\n        .subscribe(() => {\r\n          this._updateContentMargins();\r\n          this._changeDetectorRef.markForCheck();\r\n        });\r\n    }\r\n  }\r\n\r\n  /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\r\n  private _setContainerClass(isAdd: boolean): void {\r\n    if (isAdd) {\r\n      this._element.nativeElement.classList.add('mat-drawer-opened');\r\n    } else {\r\n      this._element.nativeElement.classList.remove('mat-drawer-opened');\r\n    }\r\n  }\r\n\r\n  /** Validate the state of the drawer children components. */\r\n  private _validateDrawers() {\r\n    this._start = this._end = null;\r\n\r\n    // Ensure that we have at most one start and one end drawer.\r\n    this._drawers.forEach(drawer => {\r\n      if (drawer.position == 'end') {\r\n        if (this._end != null) {\r\n          throwMatDuplicatedDrawerError('end');\r\n        }\r\n        this._end = drawer;\r\n      } else {\r\n        if (this._start != null) {\r\n          throwMatDuplicatedDrawerError('start');\r\n        }\r\n        this._start = drawer;\r\n      }\r\n    });\r\n\r\n    this._right = this._left = null;\r\n\r\n    // Detect if we're LTR or RTL.\r\n    if (this._dir && this._dir.value === 'rtl') {\r\n      this._left = this._end;\r\n      this._right = this._start;\r\n    } else {\r\n      this._left = this._start;\r\n      this._right = this._end;\r\n    }\r\n  }\r\n\r\n  /** Whether the container is being pushed to the side by one of the drawers. */\r\n  private _isPushed() {\r\n    return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\r\n           (this._isDrawerOpen(this._end) && this._end.mode != 'over');\r\n  }\r\n\r\n  _onBackdropClicked() {\r\n    this.backdropClick.emit();\r\n    this._closeModalDrawer();\r\n  }\r\n\r\n  _closeModalDrawer() {\r\n    // Close all open drawers where closing is not disabled and the mode is not `side`.\r\n    [this._start, this._end]\r\n      .filter(drawer => drawer && !drawer.disableClose && this._canHaveBackdrop(drawer))\r\n      .forEach(drawer => drawer!.close());\r\n  }\r\n\r\n  _isShowingBackdrop(): boolean {\r\n    return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||\r\n           (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));\r\n  }\r\n\r\n  private _canHaveBackdrop(drawer: MatDrawer): boolean {\r\n    return drawer.mode !== 'side' || !!this._backdropOverride;\r\n  }\r\n\r\n  private _isDrawerOpen(drawer: MatDrawer | null): drawer is MatDrawer {\r\n    return drawer != null && drawer.opened;\r\n  }\r\n\r\n  /**\r\n   * Recalculates and updates the inline styles for the content. Note that this should be used\r\n   * sparingly, because it causes a reflow.\r\n   */\r\n  private _updateContentMargins() {\r\n    // 1. For drawers in `over` mode, they don't affect the content.\r\n    // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\r\n    //    left margin (for left drawer) or right margin (for right the drawer).\r\n    // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\r\n    //    adding to the left or right margin and simultaneously subtracting the same amount of\r\n    //    margin from the other side.\r\n\r\n    let left = 0;\r\n    let right = 0;\r\n\r\n    if (this._left && this._left.opened) {\r\n      if (this._left.mode == 'side') {\r\n        left += this._left._width;\r\n      } else if (this._left.mode == 'push') {\r\n        let width = this._left._width;\r\n        left += width;\r\n        right -= width;\r\n      }\r\n    }\r\n\r\n    if (this._right && this._right.opened) {\r\n      if (this._right.mode == 'side') {\r\n        right += this._right._width;\r\n      } else if (this._right.mode == 'push') {\r\n        let width = this._right._width;\r\n        right += width;\r\n        left -= width;\r\n      }\r\n    }\r\n\r\n    // If either `right` or `left` is zero, don't set a style to the element. This\r\n    // allows users to specify a custom size via CSS class in SSR scenarios where the\r\n    // measured widths will always be zero. Note that we reset to `null` here, rather\r\n    // than below, in order to ensure that the types in the `if` below are consistent.\r\n    left = left || null!;\r\n    right = right || null!;\r\n\r\n    if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\r\n      this._contentMargins = {left, right};\r\n\r\n      // Pull back into the NgZone since in some cases we could be outside. We need to be careful\r\n      // to do it only when something changed, otherwise we can end up hitting the zone too often.\r\n      this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\r\n    }\r\n\r\n  }\r\n}\r\n"]}