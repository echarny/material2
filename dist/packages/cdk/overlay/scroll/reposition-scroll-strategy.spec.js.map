{"version":3,"file":"reposition-scroll-strategy.spec.js","sourceRoot":"","sources":["../../../../../src/cdk/overlay/scroll/reposition-scroll-strategy.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import {async, inject, TestBed} from '@angular/core/testing';\r\nimport {Component, NgModule} from '@angular/core';\r\nimport {Subject} from 'rxjs';\r\nimport {ComponentPortal, PortalModule} from '@angular/cdk/portal';\r\nimport {\r\n  Overlay,\r\n  OverlayContainer,\r\n  OverlayModule,\r\n  OverlayRef,\r\n  OverlayConfig,\r\n  ScrollDispatcher,\r\n} from '../index';\r\n\r\n\r\ndescribe('RepositionScrollStrategy', () => {\r\n  let overlayRef: OverlayRef;\r\n  let overlay: Overlay;\r\n  let componentPortal: ComponentPortal<PastaMsg>;\r\n  let scrolledSubject = new Subject();\r\n\r\n  beforeEach(async(() => {\r\n    TestBed.configureTestingModule({\r\n      imports: [OverlayModule, PortalModule, OverlayTestModule],\r\n      providers: [\r\n        {provide: ScrollDispatcher, useFactory: () => ({\r\n          scrolled: () => scrolledSubject.asObservable()\r\n        })}\r\n      ]\r\n    });\r\n\r\n    TestBed.compileComponents();\r\n  }));\r\n\r\n  beforeEach(inject([Overlay], (o: Overlay) => {\r\n    overlay = o;\r\n    componentPortal = new ComponentPortal(PastaMsg);\r\n  }));\r\n\r\n  afterEach(inject([OverlayContainer], (container: OverlayContainer) => {\r\n    overlayRef.dispose();\r\n    container.getContainerElement().parentNode!.removeChild(container.getContainerElement());\r\n  }));\r\n\r\n  it('should update the overlay position when the page is scrolled', () => {\r\n    const overlayConfig = new OverlayConfig({\r\n      scrollStrategy: overlay.scrollStrategies.reposition()\r\n    });\r\n\r\n    overlayRef = overlay.create(overlayConfig);\r\n    overlayRef.attach(componentPortal);\r\n    spyOn(overlayRef, 'updatePosition');\r\n\r\n    scrolledSubject.next();\r\n    expect(overlayRef.updatePosition).toHaveBeenCalledTimes(1);\r\n\r\n    scrolledSubject.next();\r\n    expect(overlayRef.updatePosition).toHaveBeenCalledTimes(2);\r\n  });\r\n\r\n  it('should not be updating the position after the overlay is detached', () => {\r\n    const overlayConfig = new OverlayConfig({\r\n      scrollStrategy: overlay.scrollStrategies.reposition()\r\n    });\r\n\r\n    overlayRef = overlay.create(overlayConfig);\r\n    overlayRef.attach(componentPortal);\r\n    spyOn(overlayRef, 'updatePosition');\r\n\r\n    overlayRef.detach();\r\n    scrolledSubject.next();\r\n\r\n    expect(overlayRef.updatePosition).not.toHaveBeenCalled();\r\n  });\r\n\r\n  it('should not be updating the position after the overlay is destroyed', () => {\r\n    const overlayConfig = new OverlayConfig({\r\n      scrollStrategy: overlay.scrollStrategies.reposition()\r\n    });\r\n\r\n    overlayRef = overlay.create(overlayConfig);\r\n    overlayRef.attach(componentPortal);\r\n    spyOn(overlayRef, 'updatePosition');\r\n\r\n    overlayRef.dispose();\r\n    scrolledSubject.next();\r\n\r\n    expect(overlayRef.updatePosition).not.toHaveBeenCalled();\r\n  });\r\n\r\n  it('should be able to close the overlay once it is out of view', () => {\r\n    const overlayConfig = new OverlayConfig({\r\n      scrollStrategy: overlay.scrollStrategies.reposition({\r\n        autoClose: true\r\n      })\r\n    });\r\n\r\n    overlayRef = overlay.create(overlayConfig);\r\n    overlayRef.attach(componentPortal);\r\n    spyOn(overlayRef, 'updatePosition');\r\n    spyOn(overlayRef, 'detach');\r\n    spyOn(overlayRef.overlayElement, 'getBoundingClientRect').and.returnValue({\r\n      top: -1000,\r\n      bottom: -900,\r\n      left: 0,\r\n      right: 100,\r\n      width: 100,\r\n      height: 100\r\n    });\r\n\r\n    scrolledSubject.next();\r\n    expect(overlayRef.detach).toHaveBeenCalledTimes(1);\r\n  });\r\n\r\n});\r\n\r\n\r\n/** Simple component that we can attach to the overlay. */\r\n@Component({template: '<p>Pasta</p>'})\r\nclass PastaMsg { }\r\n\r\n\r\n/** Test module to hold the component. */\r\n@NgModule({\r\n  imports: [OverlayModule, PortalModule],\r\n  declarations: [PastaMsg],\r\n  entryComponents: [PastaMsg],\r\n})\r\nclass OverlayTestModule { }\r\n"]}