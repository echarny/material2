{"version":3,"file":"focus-monitor.js","sourceRoot":"","sources":["../../../../../../src/cdk/a11y/focus-monitor/focus-monitor.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,QAAQ,EAAE,6BAA6B,EAAC,MAAM,uBAAuB,CAAC;AAC9E,OAAO,EACL,SAAS,EACT,UAAU,EACV,YAAY,EACZ,UAAU,EACV,MAAM,EAEN,QAAQ,EACR,MAAM,EACN,QAAQ,GACT,MAAM,eAAe,CAAC;AACvB,OAAO,EAAa,EAAE,IAAI,YAAY,EAAE,OAAO,EAAe,MAAM,MAAM,CAAC;;;;;AAK3E,MAAM,CAAC,qBAAM,eAAe,GAAG,GAAG,CAAC;;;;;;;;;;;;;;;;;;IAwDjC,sBAAoB,OAAe,EAAU,SAAmB;QAA5C,YAAO,GAAP,OAAO,CAAQ;QAAU,cAAS,GAAT,SAAS,CAAU;;;;uBA7BjC,IAAI;;;;8BAMV,KAAK;;;;4BAeP,IAAI,GAAG,EAAqC;;;;0CAG9B,eAAQ;;;;sCAGZ,CAAC;KAEkC;IAEpE;;;;;;OAMG;;;;;;;;IACH,8BAAO;;;;;;;IAAP,UAAQ,OAAoB,EAAE,aAA8B;QAA5D,iBAoCC;QApC6B,8BAAA,EAAA,qBAA8B;;QAE1D,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;YAC9B,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;SAC3B;;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACnC,qBAAI,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;cAChD,UAAU,GAAE,aAAa,GAAG,aAAa;YACzC,MAAM,oBAAC,UAAU,GAAE,OAAO,CAAC,YAAY,GAAG;SAC3C;;QAGD,qBAAI,IAAI,GAAyB;YAC/B,QAAQ,EAAE,eAAQ;YAClB,aAAa,EAAE,aAAa;YAC5B,OAAO,EAAE,IAAI,OAAO,EAAe;SACpC,CAAC;QACF,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,+BAA+B,EAAE,CAAC;;QAGvC,qBAAI,aAAa,GAAG,UAAC,KAAiB,IAAK,OAAA,KAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,EAA7B,CAA6B,CAAC;QACzE,qBAAI,YAAY,GAAG,UAAC,KAAiB,IAAK,OAAA,KAAI,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,EAA5B,CAA4B,CAAC;QACvE,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;YAC7B,OAAO,CAAC,gBAAgB,CAAC,OAAO,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;YACvD,OAAO,CAAC,gBAAgB,CAAC,MAAM,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;SACtD,CAAC,CAAC;;QAGH,IAAI,CAAC,QAAQ,GAAG;YACd,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;YAC1D,OAAO,CAAC,mBAAmB,CAAC,MAAM,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;SACzD,CAAC;QAEF,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;KACpC;IAED;;;OAGG;;;;;;IACH,qCAAc;;;;;IAAd,UAAe,OAAoB;QACjC,qBAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAEnD,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YAChB,WAAW,CAAC,QAAQ,EAAE,CAAC;YACvB,WAAW,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAE/B,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAC1B,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAClC,IAAI,CAAC,+BAA+B,EAAE,CAAC;SACxC;KACF;IAED;;;;;OAKG;;;;;;;;IACH,+BAAQ;;;;;;;IAAR,UAAS,OAAoB,EAAE,MAAmB,EAAE,OAAsB;QACxE,IAAI,CAAC,8BAA8B,CAAC,MAAM,CAAC,CAAC;;QAG5C,EAAE,CAAC,CAAC,OAAO,OAAO,CAAC,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC;;YAExC,mBAAC,OAAc,EAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;SACjC;KACF;;;;IAED,kCAAW;;;IAAX;QAAA,iBAEC;QADC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,KAAK,EAAE,OAAO,IAAK,OAAA,KAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAA5B,CAA4B,CAAC,CAAC;KAC7E;;;;;IAGO,+CAAwB;;;;;;;QAE9B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;YAC9B,MAAM,CAAC;SACR;;QAGD,qBAAI,uBAAuB,GAAG;YAC5B,KAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;YAC7B,KAAI,CAAC,8BAA8B,CAAC,UAAU,CAAC,CAAC;SACjD,CAAC;;;QAIF,qBAAI,yBAAyB,GAAG;YAC9B,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBAC3B,KAAI,CAAC,8BAA8B,CAAC,OAAO,CAAC,CAAC;aAC9C;SACF,CAAC;;;;QAKF,qBAAI,0BAA0B,GAAG,UAAC,KAAiB;YACjD,EAAE,CAAC,CAAC,KAAI,CAAC,eAAe,IAAI,IAAI,CAAC,CAAC,CAAC;gBACjC,YAAY,CAAC,KAAI,CAAC,eAAe,CAAC,CAAC;aACpC;YACD,KAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC,MAAM,CAAC;YACrC,KAAI,CAAC,eAAe,GAAG,UAAU,CAAC,cAAM,OAAA,KAAI,CAAC,gBAAgB,GAAG,IAAI,EAA5B,CAA4B,EAAE,eAAe,CAAC,CAAC;SACxF,CAAC;;;QAIF,qBAAI,mBAAmB,GAAG;YACxB,KAAI,CAAC,cAAc,GAAG,IAAI,CAAC;YAC3B,KAAI,CAAC,qBAAqB,GAAG,UAAU,CAAC,cAAM,OAAA,KAAI,CAAC,cAAc,GAAG,KAAK,EAA3B,CAA2B,CAAC,CAAC;SAC5E,CAAC;;;QAIF,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;YAC7B,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,uBAAuB,EAAE,IAAI,CAAC,CAAC;YACpE,QAAQ,CAAC,gBAAgB,CAAC,WAAW,EAAE,yBAAyB,EAAE,IAAI,CAAC,CAAC;YACxE,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAAE,0BAA0B,EAC9D,6BAA6B,EAAE,CAAC,CAAC,CAAC,mBAAC,EAAC,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAQ,EAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YACtF,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;SACvD,CAAC,CAAC;QAEH,IAAI,CAAC,0BAA0B,GAAG;YAChC,QAAQ,CAAC,mBAAmB,CAAC,SAAS,EAAE,uBAAuB,EAAE,IAAI,CAAC,CAAC;YACvE,QAAQ,CAAC,mBAAmB,CAAC,WAAW,EAAE,yBAAyB,EAAE,IAAI,CAAC,CAAC;YAC3E,QAAQ,CAAC,mBAAmB,CAAC,YAAY,EAAE,0BAA0B,EACjE,6BAA6B,EAAE,CAAC,CAAC,CAAC,mBAAC,EAAC,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAQ,EAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YACtF,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;;YAGzD,YAAY,CAAC,KAAI,CAAC,qBAAqB,CAAC,CAAC;YACzC,YAAY,CAAC,KAAI,CAAC,eAAe,CAAC,CAAC;YACnC,YAAY,CAAC,KAAI,CAAC,gBAAgB,CAAC,CAAC;SACrC,CAAC;;;;;;;;IAGI,mCAAY;;;;;;cAAC,OAAgB,EAAE,SAAiB,EAAE,SAAkB;QAC1E,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACd,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;SAClC;QAAC,IAAI,CAAC,CAAC;YACN,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;SACrC;;;;;;;;IAQK,kCAAW;;;;;;cAAC,OAAoB,EAAE,MAAoB;QAC5D,qBAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAEnD,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YAChB,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,aAAa,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;YACpD,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,mBAAmB,EAAE,MAAM,KAAK,OAAO,CAAC,CAAC;YACpE,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,sBAAsB,EAAE,MAAM,KAAK,UAAU,CAAC,CAAC;YAC1E,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,mBAAmB,EAAE,MAAM,KAAK,OAAO,CAAC,CAAC;YACpE,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,qBAAqB,EAAE,MAAM,KAAK,SAAS,CAAC,CAAC;SACzE;;;;;;;IAOK,qDAA8B;;;;;cAAC,MAAmB;;QACxD,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;YAC7B,KAAI,CAAC,OAAO,GAAG,MAAM,CAAC;;;;YAItB,AAHA,4FAA4F;YAC5F,wFAAwF;YACxF,yEAAyE;YACzE,KAAI,CAAC,gBAAgB,GAAG,UAAU,CAAC,cAAM,OAAA,KAAI,CAAC,OAAO,GAAG,IAAI,EAAnB,CAAmB,EAAE,CAAC,CAAC,CAAC;SAClE,CAAC,CAAC;;;;;;;IAQG,wCAAiB;;;;;cAAC,KAAiB;;;;;;;;;;;;;;;;;;QAkBzC,qBAAI,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC;QAC/B,MAAM,CAAC,IAAI,CAAC,gBAAgB,YAAY,IAAI,IAAI,WAAW,YAAY,IAAI;YACvE,CAAC,WAAW,KAAK,IAAI,CAAC,gBAAgB,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;;;;;;;;IAQrF,+BAAQ;;;;;;cAAC,KAAiB,EAAE,OAAoB;;;;;;;QAQtD,qBAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACnD,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC,WAAW,CAAC,aAAa,IAAI,OAAO,KAAK,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7E,MAAM,CAAC;SACR;;;;;;;QAQD,qBAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAC1B,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBACjD,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC;aAChC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACzC,MAAM,GAAG,OAAO,CAAC;aAClB;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,GAAG,SAAS,CAAC;aACpB;SACF;QAED,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAClC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC;;IAGjC;;;;OAIG;;;;;;;IACH,8BAAO;;;;;;IAAP,UAAQ,KAAiB,EAAE,OAAoB;;;QAG7C,qBAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAEnD,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,aAAa,IAAI,KAAK,CAAC,aAAa,YAAY,IAAI;YACjF,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3C,MAAM,CAAC;SACR;QAED,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QAC1B,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;KAC7C;;;;;;IAEO,kCAAW;;;;;cAAC,OAA6B,EAAE,MAAmB;QACpE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAM,OAAA,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAApB,CAAoB,CAAC,CAAC;;;;;IAGvC,sDAA+B;;;;;QAErC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,sBAAsB,IAAI,CAAC,CAAC,CAAC,CAAC;YACvC,IAAI,CAAC,wBAAwB,EAAE,CAAC;SACjC;;;;;IAGK,sDAA+B;;;;;QAErC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;YACnC,IAAI,CAAC,0BAA0B,EAAE,CAAC;YAClC,IAAI,CAAC,0BAA0B,GAAG,eAAQ,CAAC;SAC5C;;;gBAjUJ,UAAU,SAAC,EAAC,UAAU,EAAE,MAAM,EAAC;;;;gBAnC9B,MAAM;gBANA,QAAQ;;;uBARhB;;SAkDa,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqVvB,yBAAoB,WAAuB,EAAU,aAA2B;QAAhF,iBAKC;QALmB,gBAAW,GAAX,WAAW,CAAY;QAAU,kBAAa,GAAb,aAAa,CAAc;8BAFrD,IAAI,YAAY,EAAe;QAGxD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAClD,IAAI,CAAC,WAAW,CAAC,aAAa,EAC9B,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,YAAY,CAAC,wBAAwB,CAAC,CAAC;aACrE,SAAS,CAAC,UAAA,MAAM,IAAI,OAAA,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,EAAhC,CAAgC,CAAC,CAAC;KAC5D;;;;IAED,qCAAW;;;IAAX;QACE,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;QAClE,IAAI,CAAC,oBAAoB,CAAC,WAAW,EAAE,CAAC;KACzC;;gBAjBF,SAAS,SAAC;oBACT,QAAQ,EAAE,oDAAoD;iBAC/D;;;;gBAvXC,UAAU;gBAuCC,YAAY;;;mCAmVtB,MAAM;;0BArYT;;SAmYa,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkB5B,MAAM,yCACF,gBAA8B,EAAE,MAAc,EAAE,QAAkB;IACpE,MAAM,CAAC,gBAAgB,IAAI,IAAI,YAAY,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;CAC/D;;;;AAGD,MAAM,CAAC,qBAAM,sBAAsB,GAAG;;IAEpC,OAAO,EAAE,YAAY;IACrB,IAAI,EAAE,CAAC,CAAC,IAAI,QAAQ,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,YAAY,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC;IACxE,UAAU,EAAE,8BAA8B;CAC3C,CAAC","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {Platform, supportsPassiveEventListeners} from '@angular/cdk/platform';\r\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Injectable,\r\n  NgZone,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  SkipSelf,\r\n} from '@angular/core';\r\nimport {Observable, of as observableOf, Subject, Subscription} from 'rxjs';\r\n\r\n\r\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n// that a value of around 650ms seems appropriate.\r\nexport const TOUCH_BUFFER_MS = 650;\r\n\r\n\r\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\r\n\r\n\r\n/**\r\n * Corresponds to the options that can be passed to the native `focus` event.\r\n * via https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\r\n */\r\nexport interface FocusOptions {\r\n  /** Whether the browser should scroll to the element when it is focused. */\r\n  preventScroll?: boolean;\r\n}\r\n\r\n\r\ntype MonitoredElementInfo = {\r\n  unlisten: Function,\r\n  checkChildren: boolean,\r\n  subject: Subject<FocusOrigin>\r\n};\r\n\r\n\r\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\r\n@Injectable({providedIn: 'root'})\r\nexport class FocusMonitor implements OnDestroy {\r\n  /** The focus origin that the next focus event is a result of. */\r\n  private _origin: FocusOrigin = null;\r\n\r\n  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\r\n  private _lastFocusOrigin: FocusOrigin;\r\n\r\n  /** Whether the window has just been focused. */\r\n  private _windowFocused = false;\r\n\r\n  /** The target of the last touch event. */\r\n  private _lastTouchTarget: EventTarget | null;\r\n\r\n  /** The timeout id of the touch timeout, used to cancel timeout later. */\r\n  private _touchTimeoutId: number;\r\n\r\n  /** The timeout id of the window focus timeout. */\r\n  private _windowFocusTimeoutId: number;\r\n\r\n  /** The timeout id of the origin clearing timeout. */\r\n  private _originTimeoutId: number;\r\n\r\n  /** Map of elements being monitored to their info. */\r\n  private _elementInfo = new Map<HTMLElement, MonitoredElementInfo>();\r\n\r\n  /** A map of global objects to lists of current listeners. */\r\n  private _unregisterGlobalListeners = () => {};\r\n\r\n  /** The number of elements currently being monitored. */\r\n  private _monitoredElementCount = 0;\r\n\r\n  constructor(private _ngZone: NgZone, private _platform: Platform) {}\r\n\r\n  /**\r\n   * Monitors focus on an element and applies appropriate CSS classes.\r\n   * @param element The element to monitor\r\n   * @param checkChildren Whether to count the element as focused when its children are focused.\r\n   * @returns An observable that emits when the focus state of the element changes.\r\n   *     When the element is blurred, null will be emitted.\r\n   */\r\n  monitor(element: HTMLElement, checkChildren: boolean = false): Observable<FocusOrigin> {\r\n    // Do nothing if we're not on the browser platform.\r\n    if (!this._platform.isBrowser) {\r\n      return observableOf(null);\r\n    }\r\n    // Check if we're already monitoring this element.\r\n    if (this._elementInfo.has(element)) {\r\n      let cachedInfo = this._elementInfo.get(element);\r\n      cachedInfo!.checkChildren = checkChildren;\r\n      return cachedInfo!.subject.asObservable();\r\n    }\r\n\r\n    // Create monitored element info.\r\n    let info: MonitoredElementInfo = {\r\n      unlisten: () => {},\r\n      checkChildren: checkChildren,\r\n      subject: new Subject<FocusOrigin>()\r\n    };\r\n    this._elementInfo.set(element, info);\r\n    this._incrementMonitoredElementCount();\r\n\r\n    // Start listening. We need to listen in capture phase since focus events don't bubble.\r\n    let focusListener = (event: FocusEvent) => this._onFocus(event, element);\r\n    let blurListener = (event: FocusEvent) => this._onBlur(event, element);\r\n    this._ngZone.runOutsideAngular(() => {\r\n      element.addEventListener('focus', focusListener, true);\r\n      element.addEventListener('blur', blurListener, true);\r\n    });\r\n\r\n    // Create an unlisten function for later.\r\n    info.unlisten = () => {\r\n      element.removeEventListener('focus', focusListener, true);\r\n      element.removeEventListener('blur', blurListener, true);\r\n    };\r\n\r\n    return info.subject.asObservable();\r\n  }\r\n\r\n  /**\r\n   * Stops monitoring an element and removes all focus classes.\r\n   * @param element The element to stop monitoring.\r\n   */\r\n  stopMonitoring(element: HTMLElement): void {\r\n    const elementInfo = this._elementInfo.get(element);\r\n\r\n    if (elementInfo) {\r\n      elementInfo.unlisten();\r\n      elementInfo.subject.complete();\r\n\r\n      this._setClasses(element);\r\n      this._elementInfo.delete(element);\r\n      this._decrementMonitoredElementCount();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Focuses the element via the specified focus origin.\r\n   * @param element Element to focus.\r\n   * @param origin Focus origin.\r\n   * @param options Options that can be used to configure the focus behavior.\r\n   */\r\n  focusVia(element: HTMLElement, origin: FocusOrigin, options?: FocusOptions): void {\r\n    this._setOriginForCurrentEventQueue(origin);\r\n\r\n    // `focus` isn't available on the server\r\n    if (typeof element.focus === 'function') {\r\n      // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\r\n      (element as any).focus(options);\r\n    }\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\r\n  }\r\n\r\n  /** Register necessary event listeners on the document and window. */\r\n  private _registerGlobalListeners() {\r\n    // Do nothing if we're not on the browser platform.\r\n    if (!this._platform.isBrowser) {\r\n      return;\r\n    }\r\n\r\n    // On keydown record the origin and clear any touch event that may be in progress.\r\n    let documentKeydownListener = () => {\r\n      this._lastTouchTarget = null;\r\n      this._setOriginForCurrentEventQueue('keyboard');\r\n    };\r\n\r\n    // On mousedown record the origin only if there is not touch target, since a mousedown can\r\n    // happen as a result of a touch event.\r\n    let documentMousedownListener = () => {\r\n      if (!this._lastTouchTarget) {\r\n        this._setOriginForCurrentEventQueue('mouse');\r\n      }\r\n    };\r\n\r\n    // When the touchstart event fires the focus event is not yet in the event queue. This means\r\n    // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\r\n    // see if a focus happens.\r\n    let documentTouchstartListener = (event: TouchEvent) => {\r\n      if (this._touchTimeoutId != null) {\r\n        clearTimeout(this._touchTimeoutId);\r\n      }\r\n      this._lastTouchTarget = event.target;\r\n      this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\r\n    };\r\n\r\n    // Make a note of when the window regains focus, so we can restore the origin info for the\r\n    // focused element.\r\n    let windowFocusListener = () => {\r\n      this._windowFocused = true;\r\n      this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\r\n    };\r\n\r\n    // Note: we listen to events in the capture phase so we can detect them even if the user stops\r\n    // propagation.\r\n    this._ngZone.runOutsideAngular(() => {\r\n      document.addEventListener('keydown', documentKeydownListener, true);\r\n      document.addEventListener('mousedown', documentMousedownListener, true);\r\n      document.addEventListener('touchstart', documentTouchstartListener,\r\n          supportsPassiveEventListeners() ? ({passive: true, capture: true} as any) : true);\r\n      window.addEventListener('focus', windowFocusListener);\r\n    });\r\n\r\n    this._unregisterGlobalListeners = () => {\r\n      document.removeEventListener('keydown', documentKeydownListener, true);\r\n      document.removeEventListener('mousedown', documentMousedownListener, true);\r\n      document.removeEventListener('touchstart', documentTouchstartListener,\r\n          supportsPassiveEventListeners() ? ({passive: true, capture: true} as any) : true);\r\n      window.removeEventListener('focus', windowFocusListener);\r\n\r\n      // Clear timeouts for all potentially pending timeouts to prevent the leaks.\r\n      clearTimeout(this._windowFocusTimeoutId);\r\n      clearTimeout(this._touchTimeoutId);\r\n      clearTimeout(this._originTimeoutId);\r\n    };\r\n  }\r\n\r\n  private _toggleClass(element: Element, className: string, shouldSet: boolean) {\r\n    if (shouldSet) {\r\n      element.classList.add(className);\r\n    } else {\r\n      element.classList.remove(className);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the focus classes on the element based on the given focus origin.\r\n   * @param element The element to update the classes on.\r\n   * @param origin The focus origin.\r\n   */\r\n  private _setClasses(element: HTMLElement, origin?: FocusOrigin): void {\r\n    const elementInfo = this._elementInfo.get(element);\r\n\r\n    if (elementInfo) {\r\n      this._toggleClass(element, 'cdk-focused', !!origin);\r\n      this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\r\n      this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\r\n      this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\r\n      this._toggleClass(element, 'cdk-program-focused', origin === 'program');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the origin and schedules an async function to clear it at the end of the event queue.\r\n   * @param origin The origin to set.\r\n   */\r\n  private _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\r\n    this._ngZone.runOutsideAngular(() => {\r\n      this._origin = origin;\r\n      // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\r\n      // tick after the interaction event fired. To ensure the focus origin is always correct,\r\n      // the focus origin will be determined at the beginning of the next tick.\r\n      this._originTimeoutId = setTimeout(() => this._origin = null, 1);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks whether the given focus event was caused by a touchstart event.\r\n   * @param event The focus event to check.\r\n   * @returns Whether the event was caused by a touch.\r\n   */\r\n  private _wasCausedByTouch(event: FocusEvent): boolean {\r\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\r\n    // Consider the following dom structure:\r\n    //\r\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\r\n    //   <div #child (click)=\"#parent.focus()\"></div>\r\n    // </div>\r\n    //\r\n    // If the user touches the #child element and the #parent is programmatically focused as a\r\n    // result, this code will still consider it to have been caused by the touch event and will\r\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\r\n    // relatively small edge-case that can be worked around by using\r\n    // focusVia(parentEl, 'program') to focus the parent element.\r\n    //\r\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\r\n    // for the first focus event after the touchstart, and then the first blur event after that\r\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\r\n    // touchstart.\r\n    let focusTarget = event.target;\r\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\r\n        (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\r\n  }\r\n\r\n  /**\r\n   * Handles focus events on a registered element.\r\n   * @param event The focus event.\r\n   * @param element The monitored element.\r\n   */\r\n  private _onFocus(event: FocusEvent, element: HTMLElement) {\r\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n    // focus event affecting the monitored element. If we want to use the origin of the first event\r\n    // instead we should check for the cdk-focused class here and return if the element already has\r\n    // it. (This only matters for elements that have includesChildren = true).\r\n\r\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\r\n    // monitored element itself.\r\n    const elementInfo = this._elementInfo.get(element);\r\n    if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\r\n      return;\r\n    }\r\n\r\n    // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\r\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\r\n    //    the element from before the window blurred.\r\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\r\n    // 3) The element was programmatically focused, in which case we should mark the origin as\r\n    //    'program'.\r\n    let origin = this._origin;\r\n    if (!origin) {\r\n      if (this._windowFocused && this._lastFocusOrigin) {\r\n        origin = this._lastFocusOrigin;\r\n      } else if (this._wasCausedByTouch(event)) {\r\n        origin = 'touch';\r\n      } else {\r\n        origin = 'program';\r\n      }\r\n    }\r\n\r\n    this._setClasses(element, origin);\r\n    this._emitOrigin(elementInfo.subject, origin);\r\n    this._lastFocusOrigin = origin;\r\n  }\r\n\r\n  /**\r\n   * Handles blur events on a registered element.\r\n   * @param event The blur event.\r\n   * @param element The monitored element.\r\n   */\r\n  _onBlur(event: FocusEvent, element: HTMLElement) {\r\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\r\n    // order to focus another child of the monitored element.\r\n    const elementInfo = this._elementInfo.get(element);\r\n\r\n    if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\r\n        element.contains(event.relatedTarget))) {\r\n      return;\r\n    }\r\n\r\n    this._setClasses(element);\r\n    this._emitOrigin(elementInfo.subject, null);\r\n  }\r\n\r\n  private _emitOrigin(subject: Subject<FocusOrigin>, origin: FocusOrigin) {\r\n    this._ngZone.run(() => subject.next(origin));\r\n  }\r\n\r\n  private _incrementMonitoredElementCount() {\r\n    // Register global listeners when first element is monitored.\r\n    if (++this._monitoredElementCount == 1) {\r\n      this._registerGlobalListeners();\r\n    }\r\n  }\r\n\r\n  private _decrementMonitoredElementCount() {\r\n    // Unregister global listeners when last element is unmonitored.\r\n    if (!--this._monitoredElementCount) {\r\n      this._unregisterGlobalListeners();\r\n      this._unregisterGlobalListeners = () => {};\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\r\n * programmatically) and adds corresponding classes to the element.\r\n *\r\n * There are two variants of this directive:\r\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r\n *    focused.\r\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\r\n */\r\n@Directive({\r\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\r\n})\r\nexport class CdkMonitorFocus implements OnDestroy {\r\n  private _monitorSubscription: Subscription;\r\n  @Output() cdkFocusChange = new EventEmitter<FocusOrigin>();\r\n\r\n  constructor(private _elementRef: ElementRef, private _focusMonitor: FocusMonitor) {\r\n    this._monitorSubscription = this._focusMonitor.monitor(\r\n        this._elementRef.nativeElement,\r\n        this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\r\n        .subscribe(origin => this.cdkFocusChange.emit(origin));\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\r\n    this._monitorSubscription.unsubscribe();\r\n  }\r\n}\r\n\r\n/** @docs-private @deprecated @breaking-change 7.0.0 */\r\nexport function FOCUS_MONITOR_PROVIDER_FACTORY(\r\n    parentDispatcher: FocusMonitor, ngZone: NgZone, platform: Platform) {\r\n  return parentDispatcher || new FocusMonitor(ngZone, platform);\r\n}\r\n\r\n/** @docs-private @deprecated @breaking-change 7.0.0 */\r\nexport const FOCUS_MONITOR_PROVIDER = {\r\n  // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\r\n  provide: FocusMonitor,\r\n  deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\r\n  useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\r\n};\r\n"]}