{"version":3,"file":"list-key-manager.js","sourceRoot":"","sources":["../../../../../../src/cdk/a11y/key-manager/list-key-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {QueryList} from '@angular/core';\r\nimport {Subject, Subscription} from 'rxjs';\r\nimport {\r\n  UP_ARROW,\r\n  DOWN_ARROW,\r\n  LEFT_ARROW,\r\n  RIGHT_ARROW,\r\n  TAB,\r\n  A,\r\n  Z,\r\n  ZERO,\r\n  NINE,\r\n} from '@angular/cdk/keycodes';\r\nimport {debounceTime, filter, map, tap} from 'rxjs/operators';\r\n\r\n/** This interface is for items that can be passed to a ListKeyManager. */\r\nexport interface ListKeyManagerOption {\r\n  /** Whether the option is disabled. */\r\n  disabled?: boolean;\r\n\r\n  /** Gets the label for this option. */\r\n  getLabel?(): string;\r\n}\r\n\r\n/**\r\n * This class manages keyboard events for selectable lists. If you pass it a query list\r\n * of items, it will set the active item correctly when arrow events occur.\r\n */\r\nexport class ListKeyManager<T extends ListKeyManagerOption> {\r\n  private _activeItemIndex = -1;\r\n  private _activeItem: T;\r\n  private _wrap = false;\r\n  private _letterKeyStream = new Subject<string>();\r\n  private _typeaheadSubscription = Subscription.EMPTY;\r\n  private _vertical = true;\r\n  private _horizontal: 'ltr' | 'rtl' | null;\r\n\r\n  /**\r\n   * Predicate function that can be used to check whether an item should be skipped\r\n   * by the key manager. By default, disabled items are skipped.\r\n   */\r\n  private _skipPredicateFn = (item: T) => item.disabled;\r\n\r\n  // Buffer for the letters that the user has pressed when the typeahead option is turned on.\r\n  private _pressedLetters: string[] = [];\r\n\r\n  constructor(private _items: QueryList<T> | T[]) {\r\n    // We allow for the items to be an array because, in some cases, the consumer may\r\n    // not have access to a QueryList of the items they want to manage (e.g. when the\r\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\r\n    if (_items instanceof QueryList) {\r\n      _items.changes.subscribe((newItems: QueryList<T>) => {\r\n        if (this._activeItem) {\r\n          const itemArray = newItems.toArray();\r\n          const newIndex = itemArray.indexOf(this._activeItem);\r\n\r\n          if (newIndex > -1 && newIndex !== this._activeItemIndex) {\r\n            this._activeItemIndex = newIndex;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stream that emits any time the TAB key is pressed, so components can react\r\n   * when focus is shifted off of the list.\r\n   */\r\n  tabOut: Subject<void> = new Subject<void>();\r\n\r\n  /** Stream that emits whenever the active item of the list manager changes. */\r\n  change = new Subject<number>();\r\n\r\n  /**\r\n   * Sets the predicate function that determines which items should be skipped by the\r\n   * list key manager.\r\n   * @param predicate Function that determines whether the given item should be skipped.\r\n   */\r\n  skipPredicate(predicate: (item: T) => boolean): this {\r\n    this._skipPredicateFn = predicate;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Configures wrapping mode, which determines whether the active item will wrap to\r\n   * the other end of list when there are no more items in the given direction.\r\n   * @param shouldWrap Whether the list should wrap when reaching the end.\r\n   */\r\n  withWrap(shouldWrap = true): this {\r\n    this._wrap = shouldWrap;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Configures whether the key manager should be able to move the selection vertically.\r\n   * @param enabled Whether vertical selection should be enabled.\r\n   */\r\n  withVerticalOrientation(enabled: boolean = true): this {\r\n    this._vertical = enabled;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Configures the key manager to move the selection horizontally.\r\n   * Passing in `null` will disable horizontal movement.\r\n   * @param direction Direction in which the selection can be moved.\r\n   */\r\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\r\n    this._horizontal = direction;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Turns on typeahead mode which allows users to set the active item by typing.\r\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\r\n   */\r\n  withTypeAhead(debounceInterval: number = 200): this {\r\n    if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\r\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\r\n    }\r\n\r\n    this._typeaheadSubscription.unsubscribe();\r\n\r\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\r\n    // and convert those letters back into a string. Afterwards find the first item that starts\r\n    // with that string and select it.\r\n    this._typeaheadSubscription = this._letterKeyStream.pipe(\r\n      tap(keyCode => this._pressedLetters.push(keyCode)),\r\n      debounceTime(debounceInterval),\r\n      filter(() => this._pressedLetters.length > 0),\r\n      map(() => this._pressedLetters.join(''))\r\n    ).subscribe(inputString => {\r\n      const items = this._getItemsArray();\r\n\r\n      // Start at 1 because we want to start searching at the item immediately\r\n      // following the current active item.\r\n      for (let i = 1; i < items.length + 1; i++) {\r\n        const index = (this._activeItemIndex + i) % items.length;\r\n        const item = items[index];\r\n\r\n        if (!this._skipPredicateFn(item) &&\r\n            item.getLabel!().toUpperCase().trim().indexOf(inputString) === 0) {\r\n\r\n          this.setActiveItem(index);\r\n          break;\r\n        }\r\n      }\r\n\r\n      this._pressedLetters = [];\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the active item to the item at the index specified.\r\n   * @param index The index of the item to be set as active.\r\n   */\r\n  setActiveItem(index: number): void;\r\n\r\n  /**\r\n   * Sets the active item to the specified item.\r\n   * @param item The item to be set as active.\r\n   */\r\n  setActiveItem(item: T): void;\r\n\r\n  setActiveItem(item: any): void {\r\n    const previousIndex = this._activeItemIndex;\r\n\r\n    this.updateActiveItem(item);\r\n\r\n    if (this._activeItemIndex !== previousIndex) {\r\n      this.change.next(this._activeItemIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the active item depending on the key event passed in.\r\n   * @param event Keyboard event to be used for determining which element should be active.\r\n   */\r\n  onKeydown(event: KeyboardEvent): void {\r\n    const keyCode = event.keyCode;\r\n\r\n    switch (keyCode) {\r\n      case TAB:\r\n        this.tabOut.next();\r\n        return;\r\n\r\n      case DOWN_ARROW:\r\n        if (this._vertical) {\r\n          this.setNextItemActive();\r\n          break;\r\n        } else {\r\n          return;\r\n        }\r\n\r\n      case UP_ARROW:\r\n        if (this._vertical) {\r\n          this.setPreviousItemActive();\r\n          break;\r\n        } else {\r\n          return;\r\n        }\r\n\r\n      case RIGHT_ARROW:\r\n        if (this._horizontal === 'ltr') {\r\n          this.setNextItemActive();\r\n          break;\r\n        } else if (this._horizontal === 'rtl') {\r\n          this.setPreviousItemActive();\r\n          break;\r\n        } else {\r\n          return;\r\n        }\r\n\r\n      case LEFT_ARROW:\r\n        if (this._horizontal === 'ltr') {\r\n          this.setPreviousItemActive();\r\n          break;\r\n        } else if (this._horizontal === 'rtl') {\r\n          this.setNextItemActive();\r\n          break;\r\n        } else {\r\n          return;\r\n        }\r\n\r\n      default:\r\n        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\r\n        // otherwise fall back to resolving alphanumeric characters via the keyCode.\r\n        if (event.key && event.key.length === 1) {\r\n          this._letterKeyStream.next(event.key.toLocaleUpperCase());\r\n        } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\r\n          this._letterKeyStream.next(String.fromCharCode(keyCode));\r\n        }\r\n\r\n        // Note that we return here, in order to avoid preventing\r\n        // the default action of non-navigational keys.\r\n        return;\r\n    }\r\n\r\n    this._pressedLetters = [];\r\n    event.preventDefault();\r\n  }\r\n\r\n  /** Index of the currently active item. */\r\n  get activeItemIndex(): number | null {\r\n    return this._activeItemIndex;\r\n  }\r\n\r\n  /** The active item. */\r\n  get activeItem(): T | null {\r\n    return this._activeItem;\r\n  }\r\n\r\n  /** Sets the active item to the first enabled item in the list. */\r\n  setFirstItemActive(): void {\r\n    this._setActiveItemByIndex(0, 1);\r\n  }\r\n\r\n  /** Sets the active item to the last enabled item in the list. */\r\n  setLastItemActive(): void {\r\n    this._setActiveItemByIndex(this._items.length - 1, -1);\r\n  }\r\n\r\n  /** Sets the active item to the next enabled item in the list. */\r\n  setNextItemActive(): void {\r\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\r\n  }\r\n\r\n  /** Sets the active item to a previous enabled item in the list. */\r\n  setPreviousItemActive(): void {\r\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\r\n                                            : this._setActiveItemByDelta(-1);\r\n  }\r\n\r\n  /**\r\n   * Allows setting the active without any other effects.\r\n   * @param index Index of the item to be set as active.\r\n   */\r\n  updateActiveItem(index: number): void;\r\n\r\n  /**\r\n   * Allows setting the active item without any other effects.\r\n   * @param item Item to be set as active.\r\n   */\r\n  updateActiveItem(item: T): void;\r\n\r\n  updateActiveItem(item: any): void {\r\n    const itemArray = this._getItemsArray();\r\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\r\n\r\n    this._activeItemIndex = index;\r\n    this._activeItem = itemArray[index];\r\n  }\r\n\r\n  /**\r\n   * Allows setting of the activeItemIndex without any other effects.\r\n   * @param index The new activeItemIndex.\r\n   * @deprecated Use `updateActiveItem` instead.\r\n   * @breaking-change 7.0.0\r\n   */\r\n  updateActiveItemIndex(index: number): void {\r\n    this.updateActiveItem(index);\r\n  }\r\n\r\n  /**\r\n   * This method sets the active item, given a list of items and the delta between the\r\n   * currently active item and the new active item. It will calculate differently\r\n   * depending on whether wrap mode is turned on.\r\n   */\r\n  private _setActiveItemByDelta(delta: -1 | 1): void {\r\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\r\n  }\r\n\r\n  /**\r\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\r\n   * down the list until it finds an item that is not disabled, and it will wrap if it\r\n   * encounters either end of the list.\r\n   */\r\n  private _setActiveInWrapMode(delta: -1 | 1): void {\r\n    const items = this._getItemsArray();\r\n\r\n    for (let i = 1; i <= items.length; i++) {\r\n      const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\r\n      const item = items[index];\r\n\r\n      if (!this._skipPredicateFn(item)) {\r\n        this.setActiveItem(index);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the active item properly given the default mode. In other words, it will\r\n   * continue to move down the list until it finds an item that is not disabled. If\r\n   * it encounters either end of the list, it will stop and not wrap.\r\n   */\r\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\r\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\r\n  }\r\n\r\n  /**\r\n   * Sets the active item to the first enabled item starting at the index specified. If the\r\n   * item is disabled, it will move in the fallbackDelta direction until it either\r\n   * finds an enabled item or encounters the end of the list.\r\n   */\r\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\r\n    const items = this._getItemsArray();\r\n\r\n    if (!items[index]) {\r\n      return;\r\n    }\r\n\r\n    while (this._skipPredicateFn(items[index])) {\r\n      index += fallbackDelta;\r\n\r\n      if (!items[index]) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.setActiveItem(index);\r\n  }\r\n\r\n  /** Returns the items as an array. */\r\n  private _getItemsArray(): T[] {\r\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\r\n  }\r\n}\r\n"]}