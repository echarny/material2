{"version":3,"file":"scrollable.js","sourceRoot":"","sources":["../../../../../src/cdk/scrolling/scrollable.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,cAAc,EAAC,MAAM,mBAAmB,CAAC;AACjD,OAAO,EACL,oBAAoB,EACpB,iBAAiB,EACjB,sBAAsB,EACvB,MAAM,uBAAuB,CAAC;AAC/B,OAAO,EAAC,SAAS,EAAE,UAAU,EAAE,MAAM,EAAqB,QAAQ,EAAC,MAAM,eAAe,CAAC;AACzF,OAAO,EAAC,SAAS,EAAE,UAAU,EAAE,OAAO,EAAC,MAAM,MAAM,CAAC;AACpD,OAAO,EAAC,SAAS,EAAC,MAAM,gBAAgB,CAAC;AACzC,OAAO,EAAC,gBAAgB,EAAC,MAAM,qBAAqB,CAAC;;;;;;;IAqCnD,uBAAoB,WAAoC,EACpC,SACA,SACY;QAHhC,iBAGyD;QAHrC,gBAAW,GAAX,WAAW,CAAyB;QACpC,YAAO,GAAP,OAAO;QACP,YAAO,GAAP,OAAO;QACK,SAAI,GAAJ,IAAI;0BAVf,IAAI,OAAO,EAAE;gCAEY,UAAU,CAAC,MAAM,CAAC,UAAA,QAAQ;YACpE,OAAA,KAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;gBAC3B,OAAA,SAAS,CAAC,KAAI,CAAC,WAAW,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,KAAI,CAAC,UAAU,CAAC,CAAC;qBAC/E,SAAS,CAAC,QAAQ,CAAC;YADxB,CACwB,CAAC;QAF7B,CAE6B,CAAC;KAKuB;;;;IAEzD,gCAAQ;;;IAAR;QACE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KAC7B;;;;IAED,mCAAW;;;IAAX;QACE,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;KAC5B;IAED,sFAAsF;;;;;IACtF,uCAAe;;;;IAAf;QACE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;KAC9B;IAED,4CAA4C;;;;;IAC5C,qCAAa;;;;IAAb;QACE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;KACzB;IAED;;;;;;;OAOG;;;;;;;;;;IACH,gCAAQ;;;;;;;;;IAAR,UAAS,OAAgC;QACvC,qBAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC;QAC1C,qBAAM,KAAK,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC;;QAGpD,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC;QAC3F,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC;;QAG9F,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC;YAC3B,OAAO,CAAC,GAAG,GAAG,EAAE,CAAC,YAAY,GAAG,EAAE,CAAC,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC;SAClE;;QAGD,EAAE,CAAC,CAAC,KAAK,IAAI,oBAAoB,EAAE,IAAI,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC;YAChE,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBACzB,OAAO,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC;aAChE;YAED,EAAE,CAAC,CAAC,oBAAoB,EAAE,IAAI,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzD,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC;aAC9B;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,oBAAoB,EAAE,IAAI,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC/D,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC;aAC/D;SACF;QAAC,IAAI,CAAC,CAAC;YACN,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC;gBAC1B,OAAO,CAAC,IAAI,GAAG,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC;aAChE;SACF;QAED,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;KACrC;;;;;IAEO,6CAAqB;;;;cAAC,OAAwB;QACpD,qBAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC;QAE1C,EAAE,CAAC,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;SACtB;QAAC,IAAI,CAAC,CAAC;YACN,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC;gBACxB,EAAE,CAAC,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC;aAC5B;YACD,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBACzB,EAAE,CAAC,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC;aAC9B;SACF;;IAGH;;;;;;;;OAQG;;;;;;;;;;;IACH,2CAAmB;;;;;;;;;;IAAnB,UAAoB,IAA2D;QAC7E,qBAAM,IAAI,GAAG,MAAM,CAAC;QACpB,qBAAM,KAAK,GAAG,OAAO,CAAC;QACtB,qBAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC;QAC1C,EAAE,CAAC,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,EAAE,CAAC,SAAS,CAAC;SACrB;QACD,EAAE,CAAC,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,EAAE,CAAC,YAAY,GAAG,EAAE,CAAC,YAAY,GAAG,EAAE,CAAC,SAAS,CAAC;SACzD;;QAGD,qBAAM,KAAK,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC;QACpD,EAAE,CAAC,CAAC,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC;YACpB,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;SAC7B;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC;YACzB,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;SAC7B;QAED,EAAE,CAAC,CAAC,KAAK,IAAI,oBAAoB,EAAE,IAAI,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC;;;YAGlE,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBACjB,MAAM,CAAC,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,UAAU,CAAC;aACxD;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,EAAE,CAAC,UAAU,CAAC;aACtB;SACF;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,oBAAoB,EAAE,IAAI,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC;;;YAGxE,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBACjB,MAAM,CAAC,EAAE,CAAC,UAAU,GAAG,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,WAAW,CAAC;aACxD;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC;aACvB;SACF;QAAC,IAAI,CAAC,CAAC;;;YAGN,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBACjB,MAAM,CAAC,EAAE,CAAC,UAAU,CAAC;aACtB;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,WAAW,GAAG,EAAE,CAAC,UAAU,CAAC;aACxD;SACF;KACF;;gBAjJF,SAAS,SAAC;oBACT,QAAQ,EAAE,mCAAmC;iBAC9C;;;;gBA/BkB,UAAU;gBAGrB,gBAAgB;gBAHO,MAAM;gBAN7B,cAAc,uBAiDP,QAAQ;;wBAzDvB;;SA8Ca,aAAa","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {Directionality} from '@angular/cdk/bidi';\r\nimport {\r\n  getRtlScrollAxisType,\r\n  RtlScrollAxisType,\r\n  supportsScrollBehavior\r\n} from '@angular/cdk/platform';\r\nimport {Directive, ElementRef, NgZone, OnDestroy, OnInit, Optional} from '@angular/core';\r\nimport {fromEvent, Observable, Subject} from 'rxjs';\r\nimport {takeUntil} from 'rxjs/operators';\r\nimport {ScrollDispatcher} from './scroll-dispatcher';\r\n\r\nexport type _Without<T> = {[P in keyof T]?: never};\r\nexport type _XOR<T, U> = (_Without<T> & U) | (_Without<U> & T);\r\nexport type _Top = {top?: number};\r\nexport type _Bottom = {bottom?: number};\r\nexport type _Left = {left?: number};\r\nexport type _Right = {right?: number};\r\nexport type _Start = {start?: number};\r\nexport type _End = {end?: number};\r\nexport type _XAxis = _XOR<_XOR<_Left, _Right>, _XOR<_Start, _End>>;\r\nexport type _YAxis = _XOR<_Top, _Bottom>;\r\n\r\n/**\r\n * An extended version of ScrollToOptions that allows expressing scroll offsets relative to the\r\n * top, bottom, left, right, start, or end of the viewport rather than just the top and left.\r\n * Please note: the top and bottom properties are mutually exclusive, as are the left, right,\r\n * start, and end properties.\r\n */\r\nexport type ExtendedScrollToOptions = _XAxis & _YAxis & ScrollOptions;\r\n\r\n/**\r\n * Sends an event when the directive's element is scrolled. Registers itself with the\r\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\r\n * can be listened to through the service.\r\n */\r\n@Directive({\r\n  selector: '[cdk-scrollable], [cdkScrollable]'\r\n})\r\nexport class CdkScrollable implements OnInit, OnDestroy {\r\n  private _destroyed = new Subject();\r\n\r\n  private _elementScrolled: Observable<Event> = Observable.create(observer =>\r\n      this._ngZone.runOutsideAngular(() =>\r\n          fromEvent(this._elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\r\n              .subscribe(observer)));\r\n\r\n  constructor(private _elementRef: ElementRef<HTMLElement>,\r\n              private _scroll: ScrollDispatcher,\r\n              private _ngZone: NgZone,\r\n              @Optional() private _dir?: Directionality) {}\r\n\r\n  ngOnInit() {\r\n    this._scroll.register(this);\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._scroll.deregister(this);\r\n    this._destroyed.next();\r\n    this._destroyed.complete();\r\n  }\r\n\r\n  /** Returns observable that emits when a scroll event is fired on the host element. */\r\n  elementScrolled(): Observable<Event> {\r\n    return this._elementScrolled;\r\n  }\r\n\r\n  /** Gets the ElementRef for the viewport. */\r\n  getElementRef(): ElementRef<HTMLElement> {\r\n    return this._elementRef;\r\n  }\r\n\r\n  /**\r\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param options specified the offsets to scroll to.\r\n   */\r\n  scrollTo(options: ExtendedScrollToOptions): void {\r\n    const el = this._elementRef.nativeElement;\r\n    const isRtl = this._dir && this._dir.value == 'rtl';\r\n\r\n    // Rewrite start & end offsets as right or left offsets.\r\n    options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;\r\n    options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;\r\n\r\n    // Rewrite the bottom offset as a top offset.\r\n    if (options.bottom != null) {\r\n      options.top = el.scrollHeight - el.clientHeight - options.bottom;\r\n    }\r\n\r\n    // Rewrite the right offset as a left offset.\r\n    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {\r\n      if (options.left != null) {\r\n        options.right = el.scrollWidth - el.clientWidth - options.left;\r\n      }\r\n\r\n      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\r\n        options.left = options.right;\r\n      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\r\n        options.left = options.right ? -options.right : options.right;\r\n      }\r\n    } else {\r\n      if (options.right != null) {\r\n        options.left = el.scrollWidth - el.clientWidth - options.right;\r\n      }\r\n    }\r\n\r\n    this._applyScrollToOptions(options);\r\n  }\r\n\r\n  private _applyScrollToOptions(options: ScrollToOptions): void {\r\n    const el = this._elementRef.nativeElement;\r\n\r\n    if (supportsScrollBehavior()) {\r\n      el.scrollTo(options);\r\n    } else {\r\n      if (options.top != null) {\r\n        el.scrollTop = options.top;\r\n      }\r\n      if (options.left != null) {\r\n        el.scrollLeft = options.left;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measures the scroll offset relative to the specified edge of the viewport. This method can be\r\n   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\r\n   * about what scrollLeft means in RTL. The values returned by this method are normalized such that\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param from The edge to measure from.\r\n   */\r\n  measureScrollOffset(from: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number {\r\n    const LEFT = 'left';\r\n    const RIGHT = 'right';\r\n    const el = this._elementRef.nativeElement;\r\n    if (from == 'top') {\r\n      return el.scrollTop;\r\n    }\r\n    if (from == 'bottom') {\r\n      return el.scrollHeight - el.clientHeight - el.scrollTop;\r\n    }\r\n\r\n    // Rewrite start & end as left or right offsets.\r\n    const isRtl = this._dir && this._dir.value == 'rtl';\r\n    if (from == 'start') {\r\n      from = isRtl ? RIGHT : LEFT;\r\n    } else if (from == 'end') {\r\n      from = isRtl ? LEFT : RIGHT;\r\n    }\r\n\r\n    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\r\n      // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\r\n      // 0 when scrolled all the way right.\r\n      if (from == LEFT) {\r\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n      } else {\r\n        return el.scrollLeft;\r\n      }\r\n    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\r\n      // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\r\n      // 0 when scrolled all the way right.\r\n      if (from == LEFT) {\r\n        return el.scrollLeft + el.scrollWidth - el.clientWidth;\r\n      } else {\r\n        return -el.scrollLeft;\r\n      }\r\n    } else {\r\n      // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\r\n      // (scrollWidth - clientWidth) when scrolled all the way right.\r\n      if (from == LEFT) {\r\n        return el.scrollLeft;\r\n      } else {\r\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}