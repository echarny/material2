{"version":3,"file":"virtual-scroll-viewport.js","sourceRoot":"","sources":["../../../../../src/cdk/scrolling/virtual-scroll-viewport.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {ListRange} from '@angular/cdk/collections';\r\nimport {supportsScrollBehavior} from '@angular/cdk/platform';\r\nimport {\r\n  ChangeDetectionStrategy,\r\n  ChangeDetectorRef,\r\n  Component,\r\n  ElementRef,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  OnInit,\r\n  Output,\r\n  ViewChild,\r\n  ViewEncapsulation,\r\n} from '@angular/core';\r\nimport {animationFrameScheduler, fromEvent, Observable, Subject} from 'rxjs';\r\nimport {sampleTime, takeUntil} from 'rxjs/operators';\r\nimport {CdkVirtualForOf} from './virtual-for-of';\r\nimport {VIRTUAL_SCROLL_STRATEGY, VirtualScrollStrategy} from './virtual-scroll-strategy';\r\n\r\n\r\n/** Checks if the given ranges are equal. */\r\nfunction rangesEqual(r1: ListRange, r2: ListRange): boolean {\r\n  return r1.start == r2.start && r1.end == r2.end;\r\n}\r\n\r\n\r\n/** A viewport that virtualizes it's scrolling with the help of `CdkVirtualForOf`. */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'cdk-virtual-scroll-viewport',\r\n  templateUrl: 'virtual-scroll-viewport.html',\r\n  styleUrls: ['virtual-scroll-viewport.css'],\r\n  host: {\r\n    'class': 'cdk-virtual-scroll-viewport',\r\n    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\r\n    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation === \"vertical\"',\r\n  },\r\n  encapsulation: ViewEncapsulation.None,\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n})\r\nexport class CdkVirtualScrollViewport implements OnInit, OnDestroy {\r\n  /** Emits when the viewport is detached from a CdkVirtualForOf. */\r\n  private _detachedSubject = new Subject<void>();\r\n\r\n  /** Emits when the rendered range changes. */\r\n  private _renderedRangeSubject = new Subject<ListRange>();\r\n\r\n  /** The direction the viewport scrolls. */\r\n  @Input() orientation: 'horizontal' | 'vertical' = 'vertical';\r\n\r\n  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\r\n  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\r\n  // depending on how the strategy calculates the scrolled index, it may come at a cost to\r\n  // performance.\r\n  /** Emits when the index of the first element visible in the viewport changes. */\r\n  @Output() scrolledIndexChange: Observable<number> = Observable.create(observer =>\r\n      this._scrollStrategy.scrolledIndexChange.subscribe(index =>\r\n          Promise.resolve().then(() => this._ngZone.run(() => observer.next(index)))));\r\n\r\n  /** The element that wraps the rendered content. */\r\n  @ViewChild('contentWrapper') _contentWrapper: ElementRef<HTMLElement>;\r\n\r\n  /** A stream that emits whenever the rendered range changes. */\r\n  renderedRangeStream: Observable<ListRange> = this._renderedRangeSubject.asObservable();\r\n\r\n  /**\r\n   * The transform used to scale the spacer to the same size as all content, including content that\r\n   * is not currently rendered.\r\n   */\r\n  _totalContentSizeTransform = '';\r\n\r\n  /**\r\n   * The total size of all content (in pixels), including content that is not currently rendered.\r\n   */\r\n  private _totalContentSize = 0;\r\n\r\n  /**\r\n   * The CSS transform applied to the rendered subset of items so that they appear within the bounds\r\n   * of the visible viewport.\r\n   */\r\n  private _renderedContentTransform: string;\r\n\r\n  /** The currently rendered range of indices. */\r\n  private _renderedRange: ListRange = {start: 0, end: 0};\r\n\r\n  /** The length of the data bound to this viewport (in number of items). */\r\n  private _dataLength = 0;\r\n\r\n  /** The size of the viewport (in pixels). */\r\n  private _viewportSize = 0;\r\n\r\n  /** The pending scroll offset to be applied during the next change detection cycle. */\r\n  private _pendingScrollOffset: number | null;\r\n\r\n  /** the currently attached CdkVirtualForOf. */\r\n  private _forOf: CdkVirtualForOf<any> | null;\r\n\r\n  /** The last rendered content offset that was set. */\r\n  private _renderedContentOffset = 0;\r\n\r\n  /**\r\n   * Whether the last rendered content offset was to the end of the content (and therefore needs to\r\n   * be rewritten as an offset to the start of the content).\r\n   */\r\n  private _renderedContentOffsetNeedsRewrite = false;\r\n\r\n  /** Observable that emits when the viewport is destroyed. */\r\n  private _destroyed = new Subject<void>();\r\n\r\n  /** Whether there is a pending change detection cycle. */\r\n  private _isChangeDetectionPending = false;\r\n\r\n  /** A list of functions to run after the next change detection cycle. */\r\n  private _runAfterChangeDetection: Function[] = [];\r\n\r\n  constructor(public elementRef: ElementRef<HTMLElement>,\r\n              private _changeDetectorRef: ChangeDetectorRef,\r\n              private _ngZone: NgZone,\r\n              @Inject(VIRTUAL_SCROLL_STRATEGY) private _scrollStrategy: VirtualScrollStrategy) {}\r\n\r\n  ngOnInit() {\r\n    // It's still too early to measure the viewport at this point. Deferring with a promise allows\r\n    // the Viewport to be rendered with the correct size before we measure. We run this outside the\r\n    // zone to avoid causing more change detection cycles. We handle the change detection loop\r\n    // ourselves instead.\r\n    this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\r\n      this._measureViewportSize();\r\n      this._scrollStrategy.attach(this);\r\n\r\n      fromEvent(this.elementRef.nativeElement, 'scroll')\r\n          // Sample the scroll stream at every animation frame. This way if there are multiple\r\n          // scroll events in the same frame we only need to recheck our layout once.\r\n          .pipe(sampleTime(0, animationFrameScheduler), takeUntil(this._destroyed))\r\n          .subscribe(() => this._scrollStrategy.onContentScrolled());\r\n\r\n      this._markChangeDetectionNeeded();\r\n    }));\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.detach();\r\n    this._scrollStrategy.detach();\r\n    this._destroyed.next();\r\n\r\n    // Complete all subjects\r\n    this._renderedRangeSubject.complete();\r\n    this._detachedSubject.complete();\r\n    this._destroyed.complete();\r\n  }\r\n\r\n  /** Attaches a `CdkVirtualForOf` to this viewport. */\r\n  attach(forOf: CdkVirtualForOf<any>) {\r\n    if (this._forOf) {\r\n      throw Error('CdkVirtualScrollViewport is already attached.');\r\n    }\r\n\r\n    // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\r\n    // changes. Run outside the zone to avoid triggering change detection, since we're managing the\r\n    // change detection loop ourselves.\r\n    this._ngZone.runOutsideAngular(() => {\r\n      this._forOf = forOf;\r\n      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\r\n        const newLength = data.length;\r\n        if (newLength !== this._dataLength) {\r\n          this._dataLength = newLength;\r\n          this._scrollStrategy.onDataLengthChanged();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Detaches the current `CdkVirtualForOf`. */\r\n  detach() {\r\n    this._forOf = null;\r\n    this._detachedSubject.next();\r\n  }\r\n\r\n  /** Gets the length of the data bound to this viewport (in number of items). */\r\n  getDataLength(): number {\r\n    return this._dataLength;\r\n  }\r\n\r\n  /** Gets the size of the viewport (in pixels). */\r\n  getViewportSize(): number {\r\n    return this._viewportSize;\r\n  }\r\n\r\n  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\r\n  // cycle happens. I'm being careful to only call it after the render cycle is complete and before\r\n  // setting it to something else, but its error prone and should probably be split into\r\n  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\r\n\r\n  /** Get the current rendered range of items. */\r\n  getRenderedRange(): ListRange {\r\n    return this._renderedRange;\r\n  }\r\n\r\n  /**\r\n   * Sets the total size of all content (in pixels), including content that is not currently\r\n   * rendered.\r\n   */\r\n  setTotalContentSize(size: number) {\r\n    if (this._totalContentSize !== size) {\r\n      this._totalContentSize = size;\r\n      const axis = this.orientation == 'horizontal' ? 'X' : 'Y';\r\n      this._totalContentSizeTransform = `scale${axis}(${this._totalContentSize})`;\r\n      this._markChangeDetectionNeeded();\r\n    }\r\n  }\r\n\r\n  /** Sets the currently rendered range of indices. */\r\n  setRenderedRange(range: ListRange) {\r\n    if (!rangesEqual(this._renderedRange, range)) {\r\n      this._renderedRangeSubject.next(this._renderedRange = range);\r\n      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\r\n   */\r\n  getOffsetToRenderedContentStart(): number | null {\r\n    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\r\n  }\r\n\r\n  /**\r\n   * Sets the offset from the start of the viewport to either the start or end of the rendered data\r\n   * (in pixels).\r\n   */\r\n  setRenderedContentOffset(offset: number, to: 'to-start' | 'to-end' = 'to-start') {\r\n    const axis = this.orientation === 'horizontal' ? 'X' : 'Y';\r\n    let transform = `translate${axis}(${Number(offset)}px)`;\r\n    this._renderedContentOffset = offset;\r\n    if (to === 'to-end') {\r\n      transform += ` translate${axis}(-100%)`;\r\n      // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\r\n      // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\r\n      // expand upward).\r\n      this._renderedContentOffsetNeedsRewrite = true;\r\n    }\r\n    if (this._renderedContentTransform != transform) {\r\n      // We know this value is safe because we parse `offset` with `Number()` before passing it\r\n      // into the string.\r\n      this._renderedContentTransform = transform;\r\n      this._markChangeDetectionNeeded(() => {\r\n        if (this._renderedContentOffsetNeedsRewrite) {\r\n          this._renderedContentOffset -= this.measureRenderedContentSize();\r\n          this._renderedContentOffsetNeedsRewrite = false;\r\n          this.setRenderedContentOffset(this._renderedContentOffset);\r\n        } else {\r\n          this._scrollStrategy.onRenderedOffsetChanged();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scrolls to the offset on the viewport.\r\n   * @param offset The offset to scroll to.\r\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n   */\r\n  scrollToOffset(offset: number, behavior: ScrollBehavior = 'auto') {\r\n    const viewportElement = this.elementRef.nativeElement;\r\n\r\n    if (supportsScrollBehavior()) {\r\n      const offsetDirection = this.orientation === 'horizontal' ? 'left' : 'top';\r\n      viewportElement.scrollTo({[offsetDirection]: offset, behavior});\r\n    } else {\r\n      if (this.orientation === 'horizontal') {\r\n        viewportElement.scrollLeft = offset;\r\n      } else {\r\n        viewportElement.scrollTop = offset;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scrolls to the offset for the given index.\r\n   * @param index The index of the element to scroll to.\r\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n   */\r\n  scrollToIndex(index: number,  behavior: ScrollBehavior = 'auto') {\r\n    this._scrollStrategy.scrollToIndex(index, behavior);\r\n  }\r\n\r\n  /** @docs-private Internal method to set the scroll offset on the viewport. */\r\n  setScrollOffset(offset: number) {\r\n    // Rather than setting the offset immediately, we batch it up to be applied along with other DOM\r\n    // writes during the next change detection cycle.\r\n    this._pendingScrollOffset = offset;\r\n    this._markChangeDetectionNeeded();\r\n  }\r\n\r\n  /** Gets the current scroll offset of the viewport (in pixels). */\r\n  measureScrollOffset(): number {\r\n    return this.orientation === 'horizontal' ?\r\n        this.elementRef.nativeElement.scrollLeft : this.elementRef.nativeElement.scrollTop;\r\n  }\r\n\r\n  /** Measure the combined size of all of the rendered items. */\r\n  measureRenderedContentSize(): number {\r\n    const contentEl = this._contentWrapper.nativeElement;\r\n    return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\r\n  }\r\n\r\n  /**\r\n   * Measure the total combined size of the given range. Throws if the range includes items that are\r\n   * not rendered.\r\n   */\r\n  measureRangeSize(range: ListRange): number {\r\n    if (!this._forOf) {\r\n      return 0;\r\n    }\r\n    return this._forOf.measureRangeSize(range, this.orientation);\r\n  }\r\n\r\n  /** Update the viewport dimensions and re-render. */\r\n  checkViewportSize() {\r\n    // TODO: Cleanup later when add logic for handling content resize\r\n    this._measureViewportSize();\r\n    this._scrollStrategy.onDataLengthChanged();\r\n  }\r\n\r\n  /** Measure the viewport size. */\r\n  private _measureViewportSize() {\r\n    const viewportEl = this.elementRef.nativeElement;\r\n    this._viewportSize = this.orientation === 'horizontal' ?\r\n        viewportEl.clientWidth : viewportEl.clientHeight;\r\n  }\r\n\r\n  /** Queue up change detection to run. */\r\n  private _markChangeDetectionNeeded(runAfter?: Function) {\r\n    if (runAfter) {\r\n      this._runAfterChangeDetection.push(runAfter);\r\n    }\r\n\r\n    // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\r\n    // properties sequentially we only have to run `_doChangeDetection` once at the end.\r\n    if (!this._isChangeDetectionPending) {\r\n      this._isChangeDetectionPending = true;\r\n      this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\r\n        this._doChangeDetection();\r\n      }));\r\n    }\r\n  }\r\n\r\n  /** Run change detection. */\r\n  private _doChangeDetection() {\r\n    this._isChangeDetectionPending = false;\r\n\r\n    // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\r\n    // from the root, since the repeated items are content projected in. Calling `detectChanges`\r\n    // instead does not properly check the projected content.\r\n    this._ngZone.run(() => this._changeDetectorRef.markForCheck());\r\n    // Apply the content transform. The transform can't be set via an Angular binding because\r\n    // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\r\n    // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\r\n    // the `Number` function first to coerce it to a numeric value.\r\n    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\r\n    // Apply the pending scroll offset separately, since it can't be set up as an Angular binding.\r\n    if (this._pendingScrollOffset != null) {\r\n      if (this.orientation === 'horizontal') {\r\n        this.elementRef.nativeElement.scrollLeft = this._pendingScrollOffset;\r\n      } else {\r\n        this.elementRef.nativeElement.scrollTop = this._pendingScrollOffset;\r\n      }\r\n    }\r\n\r\n    const runAfterChangeDetection = this._runAfterChangeDetection;\r\n    this._runAfterChangeDetection = [];\r\n    for (const fn of runAfterChangeDetection) {\r\n      fn();\r\n    }\r\n  }\r\n}\r\n"]}