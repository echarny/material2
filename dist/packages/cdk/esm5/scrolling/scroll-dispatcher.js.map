{"version":3,"file":"scroll-dispatcher.js","sourceRoot":"","sources":["../../../../../src/cdk/scrolling/scroll-dispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {\r\n  ElementRef,\r\n  Injectable,\r\n  NgZone,\r\n  OnDestroy,\r\n  Optional,\r\n  SkipSelf,\r\n} from '@angular/core';\r\nimport {fromEvent, of as observableOf, Subject, Subscription, Observable} from 'rxjs';\r\nimport {auditTime, filter} from 'rxjs/operators';\r\nimport {CdkScrollable} from './scrollable';\r\n\r\n\r\n/** Time in ms to throttle the scrolling events by default. */\r\nexport const DEFAULT_SCROLL_TIME = 20;\r\n\r\n/**\r\n * Service contained all registered Scrollable references and emits an event when any one of the\r\n * Scrollable references emit a scrolled event.\r\n */\r\n@Injectable({providedIn: 'root'})\r\nexport class ScrollDispatcher implements OnDestroy {\r\n  constructor(private _ngZone: NgZone, private _platform: Platform) { }\r\n\r\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\r\n  private _scrolled = new Subject<CdkScrollable|void>();\r\n\r\n  /** Keeps track of the global `scroll` and `resize` subscriptions. */\r\n  _globalSubscription: Subscription | null = null;\r\n\r\n  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\r\n  private _scrolledCount = 0;\r\n\r\n  /**\r\n   * Map of all the scrollable references that are registered with the service and their\r\n   * scroll event subscriptions.\r\n   */\r\n  scrollContainers: Map<CdkScrollable, Subscription> = new Map();\r\n\r\n  /**\r\n   * Registers a scrollable instance with the service and listens for its scrolled events. When the\r\n   * scrollable is scrolled, the service emits the event to its scrolled observable.\r\n   * @param scrollable Scrollable instance to be registered.\r\n   */\r\n  register(scrollable: CdkScrollable): void {\r\n    const scrollSubscription = scrollable.elementScrolled()\r\n        .subscribe(() => this._scrolled.next(scrollable));\r\n\r\n    this.scrollContainers.set(scrollable, scrollSubscription);\r\n  }\r\n\r\n  /**\r\n   * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\r\n   * @param scrollable Scrollable instance to be deregistered.\r\n   */\r\n  deregister(scrollable: CdkScrollable): void {\r\n    const scrollableReference = this.scrollContainers.get(scrollable);\r\n\r\n    if (scrollableReference) {\r\n      scrollableReference.unsubscribe();\r\n      this.scrollContainers.delete(scrollable);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an observable that emits an event whenever any of the registered Scrollable\r\n   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\r\n   * to override the default \"throttle\" time.\r\n   *\r\n   * **Note:** in order to avoid hitting change detection for every scroll event,\r\n   * all of the events emitted from this stream will be run outside the Angular zone.\r\n   * If you need to update any data bindings as a result of a scroll event, you have\r\n   * to run the callback using `NgZone.run`.\r\n   */\r\n  scrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME): Observable<CdkScrollable|void> {\r\n    return this._platform.isBrowser ? Observable.create(observer => {\r\n      if (!this._globalSubscription) {\r\n        this._addGlobalListener();\r\n      }\r\n\r\n      // In the case of a 0ms delay, use an observable without auditTime\r\n      // since it does add a perceptible delay in processing overhead.\r\n      const subscription = auditTimeInMs > 0 ?\r\n        this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\r\n        this._scrolled.subscribe(observer);\r\n\r\n      this._scrolledCount++;\r\n\r\n      return () => {\r\n        subscription.unsubscribe();\r\n        this._scrolledCount--;\r\n\r\n        if (!this._scrolledCount) {\r\n          this._removeGlobalListener();\r\n        }\r\n      };\r\n    }) : observableOf<void>();\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._removeGlobalListener();\r\n    this.scrollContainers.forEach((_, container) => this.deregister(container));\r\n    this._scrolled.complete();\r\n  }\r\n\r\n  /**\r\n   * Returns an observable that emits whenever any of the\r\n   * scrollable ancestors of an element are scrolled.\r\n   * @param elementRef Element whose ancestors to listen for.\r\n   * @param auditTimeInMs Time to throttle the scroll events.\r\n   */\r\n  ancestorScrolled(elementRef: ElementRef, auditTimeInMs?: number): Observable<CdkScrollable|void> {\r\n    const ancestors = this.getAncestorScrollContainers(elementRef);\r\n\r\n    return this.scrolled(auditTimeInMs).pipe(filter(target => {\r\n      return !target || ancestors.indexOf(target) > -1;\r\n    }));\r\n  }\r\n\r\n  /** Returns all registered Scrollables that contain the provided element. */\r\n  getAncestorScrollContainers(elementRef: ElementRef): CdkScrollable[] {\r\n    const scrollingContainers: CdkScrollable[] = [];\r\n\r\n    this.scrollContainers.forEach((_subscription: Subscription, scrollable: CdkScrollable) => {\r\n      if (this._scrollableContainsElement(scrollable, elementRef)) {\r\n        scrollingContainers.push(scrollable);\r\n      }\r\n    });\r\n\r\n    return scrollingContainers;\r\n  }\r\n\r\n  /** Returns true if the element is contained within the provided Scrollable. */\r\n  private _scrollableContainsElement(scrollable: CdkScrollable, elementRef: ElementRef): boolean {\r\n    let element = elementRef.nativeElement;\r\n    let scrollableElement = scrollable.getElementRef().nativeElement;\r\n\r\n    // Traverse through the element parents until we reach null, checking if any of the elements\r\n    // are the scrollable's element.\r\n    do {\r\n      if (element == scrollableElement) { return true; }\r\n    } while (element = element.parentElement);\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Sets up the global scroll listeners. */\r\n  private _addGlobalListener() {\r\n    this._globalSubscription = this._ngZone.runOutsideAngular(() => {\r\n      return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\r\n    });\r\n  }\r\n\r\n  /** Cleans up the global scroll listener. */\r\n  private _removeGlobalListener() {\r\n    if (this._globalSubscription) {\r\n      this._globalSubscription.unsubscribe();\r\n      this._globalSubscription = null;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/** @docs-private @deprecated @breaking-change 7.0.0 */\r\nexport function SCROLL_DISPATCHER_PROVIDER_FACTORY(\r\n    parentDispatcher: ScrollDispatcher, ngZone: NgZone, platform: Platform) {\r\n  return parentDispatcher || new ScrollDispatcher(ngZone, platform);\r\n}\r\n\r\n/** @docs-private @deprecated @breaking-change 7.0.0 */\r\nexport const SCROLL_DISPATCHER_PROVIDER = {\r\n  // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\r\n  provide: ScrollDispatcher,\r\n  deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\r\n  useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\r\n};\r\n"]}