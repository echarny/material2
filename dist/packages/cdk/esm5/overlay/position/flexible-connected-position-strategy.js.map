{"version":3,"file":"flexible-connected-position-strategy.js","sourceRoot":"","sources":["../../../../../../src/cdk/overlay/position/flexible-connected-position-strategy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {PositionStrategy} from './position-strategy';\r\nimport {ElementRef} from '@angular/core';\r\nimport {ViewportRuler, CdkScrollable} from '@angular/cdk/scrolling';\r\nimport {\r\n  ConnectedOverlayPositionChange,\r\n  ConnectionPositionPair,\r\n  ScrollingVisibility,\r\n  validateHorizontalPosition,\r\n  validateVerticalPosition,\r\n} from './connected-position';\r\nimport {Observable, Subscription, Subject} from 'rxjs';\r\nimport {OverlayReference} from '../overlay-reference';\r\nimport {isElementScrolledOutsideView, isElementClippedByScrolling} from './scroll-clip';\r\nimport {coerceCssPixelValue} from '@angular/cdk/coercion';\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {OverlayContainer} from '../overlay-container';\r\n\r\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\r\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\r\n\r\n/**\r\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\r\n * implicit position relative some origin element. The relative position is defined in terms of\r\n * a point on the origin element that is connected to a point on the overlay element. For example,\r\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\r\n * of the overlay.\r\n */\r\nexport class FlexibleConnectedPositionStrategy implements PositionStrategy {\r\n  /** The overlay to which this strategy is attached. */\r\n  private _overlayRef: OverlayReference;\r\n\r\n  /** Whether we're performing the very first positioning of the overlay. */\r\n  private _isInitialRender = true;\r\n\r\n  /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\r\n  private _lastBoundingBoxSize = {width: 0, height: 0};\r\n\r\n  /** Whether the overlay was pushed in a previous positioning. */\r\n  private _isPushed = false;\r\n\r\n  /** Whether the overlay can be pushed on-screen on the initial open. */\r\n  private _canPush = true;\r\n\r\n  /** Whether the overlay can grow via flexible width/height after the initial open. */\r\n  private _growAfterOpen = false;\r\n\r\n  /** Whether the overlay's width and height can be constrained to fit within the viewport. */\r\n  private _hasFlexibleDimensions = true;\r\n\r\n  /** Whether the overlay position is locked. */\r\n  private _positionLocked = false;\r\n\r\n  /** Cached origin dimensions */\r\n  private _originRect: ClientRect;\r\n\r\n  /** Cached overlay dimensions */\r\n  private _overlayRect: ClientRect;\r\n\r\n  /** Cached viewport dimensions */\r\n  private _viewportRect: ClientRect;\r\n\r\n  /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\r\n  private _viewportMargin = 0;\r\n\r\n  /** The Scrollable containers used to check scrollable view properties on position change. */\r\n  private scrollables: CdkScrollable[] = [];\r\n\r\n  /** Ordered list of preferred positions, from most to least desirable. */\r\n  _preferredPositions: ConnectionPositionPair[] = [];\r\n\r\n  /** The origin element against which the overlay will be positioned. */\r\n  private _origin: HTMLElement;\r\n\r\n  /** The overlay pane element. */\r\n  private _pane: HTMLElement;\r\n\r\n  /** Whether the strategy has been disposed of already. */\r\n  private _isDisposed: boolean;\r\n\r\n  /**\r\n   * Parent element for the overlay panel used to constrain the overlay panel's size to fit\r\n   * within the viewport.\r\n   */\r\n  private _boundingBox: HTMLElement | null;\r\n\r\n  /** The last position to have been calculated as the best fit position. */\r\n  private _lastPosition: ConnectedPosition | null;\r\n\r\n  /** Subject that emits whenever the position changes. */\r\n  private _positionChanges = new Subject<ConnectedOverlayPositionChange>();\r\n\r\n  /** Subscription to viewport size changes. */\r\n  private _resizeSubscription = Subscription.EMPTY;\r\n\r\n  /** Default offset for the overlay along the x axis. */\r\n  private _offsetX = 0;\r\n\r\n  /** Default offset for the overlay along the y axis. */\r\n  private _offsetY = 0;\r\n\r\n  /** Selector to be used when finding the elements on which to set the transform origin. */\r\n  private _transformOriginSelector: string;\r\n\r\n  /** Amount of subscribers to the `positionChanges` stream. */\r\n  private _positionChangeSubscriptions = 0;\r\n\r\n  /** Observable sequence of position changes. */\r\n  positionChanges: Observable<ConnectedOverlayPositionChange> = Observable.create(observer => {\r\n    const subscription = this._positionChanges.subscribe(observer);\r\n    this._positionChangeSubscriptions++;\r\n\r\n    return () => {\r\n      subscription.unsubscribe();\r\n      this._positionChangeSubscriptions--;\r\n    };\r\n  });\r\n\r\n  /** Ordered list of preferred positions, from most to least desirable. */\r\n  get positions() {\r\n    return this._preferredPositions;\r\n  }\r\n\r\n  constructor(\r\n    connectedTo: ElementRef | HTMLElement,\r\n    private _viewportRuler: ViewportRuler,\r\n    private _document: Document,\r\n    // @breaking-change 7.0.0 `_platform` and `_overlayContainer` parameters to be made required.\r\n    private _platform?: Platform,\r\n    private _overlayContainer?: OverlayContainer) {\r\n    this.setOrigin(connectedTo);\r\n  }\r\n\r\n  /** Attaches this position strategy to an overlay. */\r\n  attach(overlayRef: OverlayReference): void {\r\n    if (this._overlayRef && overlayRef !== this._overlayRef) {\r\n      throw Error('This position strategy is already attached to an overlay');\r\n    }\r\n\r\n    this._validatePositions();\r\n\r\n    overlayRef.hostElement.classList.add('cdk-overlay-connected-position-bounding-box');\r\n\r\n    this._overlayRef = overlayRef;\r\n    this._boundingBox = overlayRef.hostElement;\r\n    this._pane = overlayRef.overlayElement;\r\n    this._resizeSubscription.unsubscribe();\r\n    this._resizeSubscription = this._viewportRuler.change().subscribe(() => this.apply());\r\n  }\r\n\r\n  /**\r\n   * Updates the position of the overlay element, using whichever preferred position relative\r\n   * to the origin best fits on-screen.\r\n   *\r\n   * The selection of a position goes as follows:\r\n   *  - If any positions fit completely within the viewport as-is,\r\n   *      choose the first position that does so.\r\n   *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\r\n   *      choose the position with the greatest available size modified by the positions' weight.\r\n   *  - If pushing is enabled, take the position that went off-screen the least and push it\r\n   *      on-screen.\r\n   *  - If none of the previous criteria were met, use the position that goes off-screen the least.\r\n   * @docs-private\r\n   */\r\n  apply(): void {\r\n    // We shouldn't do anything if the strategy was disposed or we're on the server.\r\n    // @breaking-change 7.0.0 Remove `_platform` null check once it's guaranteed to be defined.\r\n    if (this._isDisposed || (this._platform && !this._platform.isBrowser)) {\r\n      return;\r\n    }\r\n\r\n    // If the position has been applied already (e.g. when the overlay was opened) and the\r\n    // consumer opted into locking in the position, re-use the old position, in order to\r\n    // prevent the overlay from jumping around.\r\n    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\r\n      this.reapplyLastPosition();\r\n      return;\r\n    }\r\n\r\n    this._resetOverlayElementStyles();\r\n    this._resetBoundingBoxStyles();\r\n\r\n    // We need the bounding rects for the origin and the overlay to determine how to position\r\n    // the overlay relative to the origin.\r\n    // We use the viewport rect to determine whether a position would go off-screen.\r\n    this._viewportRect = this._getNarrowedViewportRect();\r\n    this._originRect = this._origin.getBoundingClientRect();\r\n    this._overlayRect = this._pane.getBoundingClientRect();\r\n\r\n    const originRect = this._originRect;\r\n    const overlayRect = this._overlayRect;\r\n    const viewportRect = this._viewportRect;\r\n\r\n    // Positions where the overlay will fit with flexible dimensions.\r\n    const flexibleFits: FlexibleFit[] = [];\r\n\r\n    // Fallback if none of the preferred positions fit within the viewport.\r\n    let fallback: FallbackPosition | undefined;\r\n\r\n    // Go through each of the preferred positions looking for a good fit.\r\n    // If a good fit is found, it will be applied immediately.\r\n    for (let pos of this._preferredPositions) {\r\n      // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\r\n      let originPoint = this._getOriginPoint(originRect, pos);\r\n\r\n      // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\r\n      // overlay in this position. We use the top-left corner for calculations and later translate\r\n      // this into an appropriate (top, left, bottom, right) style.\r\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\r\n\r\n      // Calculate how well the overlay would fit into the viewport with this point.\r\n      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\r\n\r\n      // If the overlay, without any further work, fits into the viewport, use this position.\r\n      if (overlayFit.isCompletelyWithinViewport) {\r\n        this._isPushed = false;\r\n        this._applyPosition(pos, originPoint);\r\n        return;\r\n      }\r\n\r\n      // If the overlay has flexible dimensions, we can use this position\r\n      // so long as there's enough space for the minimum dimensions.\r\n      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\r\n        // Save positions where the overlay will fit with flexible dimensions. We will use these\r\n        // if none of the positions fit *without* flexible dimensions.\r\n        flexibleFits.push({\r\n          position: pos,\r\n          origin: originPoint,\r\n          overlayRect,\r\n          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\r\n        });\r\n\r\n        continue;\r\n      }\r\n\r\n      // If the current preferred position does not fit on the screen, remember the position\r\n      // if it has more visible area on-screen than we've seen and move onto the next preferred\r\n      // position.\r\n      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\r\n        fallback = {overlayFit, overlayPoint, originPoint, position: pos, overlayRect};\r\n      }\r\n    }\r\n\r\n    // If there are any positions where the overlay would fit with flexible dimensions, choose the\r\n    // one that has the greatest area available modified by the position's weight\r\n    if (flexibleFits.length) {\r\n      let bestFit: FlexibleFit | null = null;\r\n      let bestScore = -1;\r\n      for (const fit of flexibleFits) {\r\n        const score =\r\n            fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\r\n        if (score > bestScore) {\r\n          bestScore = score;\r\n          bestFit = fit;\r\n        }\r\n      }\r\n\r\n      this._isPushed = false;\r\n      this._applyPosition(bestFit!.position, bestFit!.origin);\r\n      return;\r\n    }\r\n\r\n    // When none of the preferred positions fit within the viewport, take the position\r\n    // that went off-screen the least and attempt to push it on-screen.\r\n    if (this._canPush) {\r\n      // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\r\n      this._isPushed = true;\r\n      this._applyPosition(fallback!.position, fallback!.originPoint);\r\n      return;\r\n    }\r\n\r\n    // All options for getting the overlay within the viewport have been exhausted, so go with the\r\n    // position that went off-screen the least.\r\n    this._applyPosition(fallback!.position, fallback!.originPoint);\r\n  }\r\n\r\n  detach() {\r\n    this._resizeSubscription.unsubscribe();\r\n  }\r\n\r\n  /** Cleanup after the element gets destroyed. */\r\n  dispose() {\r\n    if (!this._isDisposed) {\r\n      this.detach();\r\n      this._boundingBox = null;\r\n      this._positionChanges.complete();\r\n      this._isDisposed = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This re-aligns the overlay element with the trigger in its last calculated position,\r\n   * even if a position higher in the \"preferred positions\" list would now fit. This\r\n   * allows one to re-align the panel without changing the orientation of the panel.\r\n   */\r\n  reapplyLastPosition(): void {\r\n    if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\r\n      this._originRect = this._origin.getBoundingClientRect();\r\n      this._overlayRect = this._pane.getBoundingClientRect();\r\n      this._viewportRect = this._getNarrowedViewportRect();\r\n\r\n      const lastPosition = this._lastPosition || this._preferredPositions[0];\r\n      const originPoint = this._getOriginPoint(this._originRect, lastPosition);\r\n\r\n      this._applyPosition(lastPosition, originPoint);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the list of Scrollable containers that host the origin element so that\r\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\r\n   * Scrollable must be an ancestor element of the strategy's origin element.\r\n   */\r\n  withScrollableContainers(scrollables: CdkScrollable[]) {\r\n    this.scrollables = scrollables;\r\n  }\r\n\r\n  /**\r\n   * Adds new preferred positions.\r\n   * @param positions List of positions options for this overlay.\r\n   */\r\n  withPositions(positions: ConnectedPosition[]): this {\r\n    this._preferredPositions = positions;\r\n\r\n    // If the last calculated position object isn't part of the positions anymore, clear\r\n    // it in order to avoid it being picked up if the consumer tries to re-apply.\r\n    if (positions.indexOf(this._lastPosition!) === -1) {\r\n      this._lastPosition = null;\r\n    }\r\n\r\n    this._validatePositions();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\r\n   * @param margin Required margin between the overlay and the viewport edge in pixels.\r\n   */\r\n  withViewportMargin(margin: number): this {\r\n    this._viewportMargin = margin;\r\n    return this;\r\n  }\r\n\r\n  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\r\n  withFlexibleDimensions(flexibleDimensions = true): this {\r\n    this._hasFlexibleDimensions = flexibleDimensions;\r\n    return this;\r\n  }\r\n\r\n  /** Sets whether the overlay can grow after the initial open via flexible width/height. */\r\n  withGrowAfterOpen(growAfterOpen = true): this {\r\n    this._growAfterOpen = growAfterOpen;\r\n    return this;\r\n  }\r\n\r\n  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\r\n  withPush(canPush = true): this {\r\n    this._canPush = canPush;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets whether the overlay's position should be locked in after it is positioned\r\n   * initially. When an overlay is locked in, it won't attempt to reposition itself\r\n   * when the position is re-applied (e.g. when the user scrolls away).\r\n   * @param isLocked Whether the overlay should locked in.\r\n   */\r\n  withLockedPosition(isLocked = true): this {\r\n    this._positionLocked = isLocked;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the origin element, relative to which to position the overlay.\r\n   * @param origin Reference to the new origin element.\r\n   */\r\n  setOrigin(origin: ElementRef | HTMLElement): this {\r\n    this._origin = origin instanceof ElementRef ? origin.nativeElement : origin;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the default offset for the overlay's connection point on the x-axis.\r\n   * @param offset New offset in the X axis.\r\n   */\r\n  withDefaultOffsetX(offset: number): this {\r\n    this._offsetX = offset;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the default offset for the overlay's connection point on the y-axis.\r\n   * @param offset New offset in the Y axis.\r\n   */\r\n  withDefaultOffsetY(offset: number): this {\r\n    this._offsetY = offset;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Configures that the position strategy should set a `transform-origin` on some elements\r\n   * inside the overlay, depending on the current position that is being applied. This is\r\n   * useful for the cases where the origin of an animation can change depending on the\r\n   * alignment of the overlay.\r\n   * @param selector CSS selector that will be used to find the target\r\n   *    elements onto which to set the transform origin.\r\n   */\r\n  withTransformOriginOn(selector: string): this {\r\n    this._transformOriginSelector = selector;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\r\n   */\r\n  private _getOriginPoint(originRect: ClientRect, pos: ConnectedPosition): Point {\r\n    let x: number;\r\n    if (pos.originX == 'center') {\r\n      // Note: when centering we should always use the `left`\r\n      // offset, otherwise the position will be wrong in RTL.\r\n      x = originRect.left + (originRect.width / 2);\r\n    } else {\r\n      const startX = this._isRtl() ? originRect.right : originRect.left;\r\n      const endX = this._isRtl() ? originRect.left : originRect.right;\r\n      x = pos.originX == 'start' ? startX : endX;\r\n    }\r\n\r\n    let y: number;\r\n    if (pos.originY == 'center') {\r\n      y = originRect.top + (originRect.height / 2);\r\n    } else {\r\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\r\n    }\r\n\r\n    return {x, y};\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\r\n   * origin point to which the overlay should be connected.\r\n   */\r\n  private _getOverlayPoint(\r\n      originPoint: Point,\r\n      overlayRect: ClientRect,\r\n      pos: ConnectedPosition): Point {\r\n\r\n    // Calculate the (overlayStartX, overlayStartY), the start of the\r\n    // potential overlay position relative to the origin point.\r\n    let overlayStartX: number;\r\n    if (pos.overlayX == 'center') {\r\n      overlayStartX = -overlayRect.width / 2;\r\n    } else if (pos.overlayX === 'start') {\r\n      overlayStartX = this._isRtl() ? -overlayRect.width : 0;\r\n    } else {\r\n      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\r\n    }\r\n\r\n    let overlayStartY: number;\r\n    if (pos.overlayY == 'center') {\r\n      overlayStartY = -overlayRect.height / 2;\r\n    } else {\r\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\r\n    }\r\n\r\n    // The (x, y) coordinates of the overlay.\r\n    return {\r\n      x: originPoint.x + overlayStartX,\r\n      y: originPoint.y + overlayStartY,\r\n    };\r\n  }\r\n\r\n  /** Gets how well an overlay at the given point will fit within the viewport. */\r\n  private _getOverlayFit(point: Point, overlay: ClientRect, viewport: ClientRect,\r\n    position: ConnectedPosition): OverlayFit {\r\n\r\n    let {x, y} = point;\r\n    let offsetX = this._getOffset(position, 'x');\r\n    let offsetY = this._getOffset(position, 'y');\r\n\r\n    // Account for the offsets since they could push the overlay out of the viewport.\r\n    if (offsetX) {\r\n      x += offsetX;\r\n    }\r\n\r\n    if (offsetY) {\r\n      y += offsetY;\r\n    }\r\n\r\n    // How much the overlay would overflow at this position, on each side.\r\n    let leftOverflow = 0 - x;\r\n    let rightOverflow = (x + overlay.width) - viewport.width;\r\n    let topOverflow = 0 - y;\r\n    let bottomOverflow = (y + overlay.height) - viewport.height;\r\n\r\n    // Visible parts of the element on each axis.\r\n    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\r\n    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\r\n    let visibleArea = visibleWidth * visibleHeight;\r\n\r\n    return {\r\n      visibleArea,\r\n      isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\r\n      fitsInViewportVertically: visibleHeight === overlay.height,\r\n      fitsInViewportHorizontally: visibleWidth == overlay.width,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Whether the overlay can fit within the viewport when it may resize either its width or height.\r\n   * @param fit How well the overlay fits in the viewport at some position.\r\n   * @param point The (x, y) coordinates of the overlat at some position.\r\n   * @param viewport The geometry of the viewport.\r\n   */\r\n  private _canFitWithFlexibleDimensions(fit: OverlayFit, point: Point, viewport: ClientRect) {\r\n    if (this._hasFlexibleDimensions) {\r\n      const availableHeight = viewport.bottom - point.y;\r\n      const availableWidth = viewport.right - point.x;\r\n      const minHeight = this._overlayRef.getConfig().minHeight;\r\n      const minWidth = this._overlayRef.getConfig().minWidth;\r\n\r\n      const verticalFit = fit.fitsInViewportVertically ||\r\n          (minHeight != null && minHeight <= availableHeight);\r\n      const horizontalFit = fit.fitsInViewportHorizontally ||\r\n          (minWidth != null && minWidth <= availableWidth);\r\n\r\n      return verticalFit && horizontalFit;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\r\n   * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\r\n   * right and bottom).\r\n   *\r\n   * @param start The starting point from which the overlay is pushed.\r\n   * @param overlay The overlay dimensions.\r\n   * @returns The point at which to position the overlay after pushing. This is effectively a new\r\n   *     originPoint.\r\n   */\r\n  private _pushOverlayOnScreen(start: Point, overlay: ClientRect): Point {\r\n    const viewport = this._viewportRect;\r\n\r\n    // Determine how much the overlay goes outside the viewport on each side, which we'll use to\r\n    // decide which direction to push it.\r\n    const overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);\r\n    const overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);\r\n    const overflowTop = Math.max(viewport.top - start.y, 0);\r\n    const overflowLeft = Math.max(viewport.left - start.x, 0);\r\n\r\n    // Amount by which to push the overlay in each direction such that it remains on-screen.\r\n    let pushX, pushY = 0;\r\n\r\n    // If the overlay fits completely within the bounds of the viewport, push it from whichever\r\n    // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\r\n    // viewport and allow for the trailing end of the overlay to go out of bounds.\r\n    if (overlay.width <= viewport.width) {\r\n      pushX = overflowLeft || -overflowRight;\r\n    } else {\r\n      pushX = viewport.left - start.x;\r\n    }\r\n\r\n    if (overlay.height <= viewport.height) {\r\n      pushY = overflowTop || -overflowBottom;\r\n    } else {\r\n      pushY = viewport.top - start.y;\r\n    }\r\n\r\n    return {\r\n      x: start.x + pushX,\r\n      y: start.y + pushY,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Applies a computed position to the overlay and emits a position change.\r\n   * @param position The position preference\r\n   * @param originPoint The point on the origin element where the overlay is connected.\r\n   */\r\n  private _applyPosition(position: ConnectedPosition, originPoint: Point) {\r\n    this._setTransformOrigin(position);\r\n    this._setOverlayElementStyles(originPoint, position);\r\n    this._setBoundingBoxStyles(originPoint, position);\r\n\r\n    // Save the last connected position in case the position needs to be re-calculated.\r\n    this._lastPosition = position;\r\n\r\n    // Notify that the position has been changed along with its change properties.\r\n    // We only emit if we've got any subscriptions, because the scroll visibility\r\n    // calculcations can be somewhat expensive.\r\n    if (this._positionChangeSubscriptions > 0) {\r\n      const scrollableViewProperties = this._getScrollVisibility();\r\n      const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\r\n      this._positionChanges.next(changeEvent);\r\n    }\r\n\r\n    this._isInitialRender = false;\r\n  }\r\n\r\n  /** Sets the transform origin based on the configured selector and the passed-in position.  */\r\n  private _setTransformOrigin(position: ConnectedPosition) {\r\n    if (!this._transformOriginSelector) {\r\n      return;\r\n    }\r\n\r\n    const elements: NodeListOf<HTMLElement> =\r\n        this._boundingBox!.querySelectorAll(this._transformOriginSelector);\r\n    let xOrigin: 'left' | 'right' | 'center';\r\n    let yOrigin: 'top' | 'bottom' | 'center' = position.overlayY;\r\n\r\n    if (position.overlayX === 'center') {\r\n      xOrigin = 'center';\r\n    } else if (this._isRtl()) {\r\n      xOrigin = position.overlayX === 'start' ? 'right' : 'left';\r\n    } else {\r\n      xOrigin = position.overlayX === 'start' ? 'left' : 'right';\r\n    }\r\n\r\n    for (let i = 0; i < elements.length; i++) {\r\n      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the position and size of the overlay's sizing container.\r\n   *\r\n   * This method does no measuring and applies no styles so that we can cheaply compute the\r\n   * bounds for all positions and choose the best fit based on these results.\r\n   */\r\n  private _calculateBoundingBoxRect(origin: Point, position: ConnectedPosition): BoundingBoxRect {\r\n    const viewport = this._viewportRect;\r\n    const isRtl = this._isRtl();\r\n    let height, top, bottom;\r\n\r\n    if (position.overlayY === 'top') {\r\n      // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\r\n      top = origin.y;\r\n      height = viewport.bottom - origin.y;\r\n    } else if (position.overlayY === 'bottom') {\r\n      // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\r\n      // the viewport margin back in, because the viewport rect is narrowed down to remove the\r\n      // margin, whereas the `origin` position is calculated based on its `ClientRect`.\r\n      bottom = viewport.height - origin.y + this._viewportMargin * 2;\r\n      height = viewport.height - bottom + this._viewportMargin;\r\n    } else {\r\n      // If neither top nor bottom, it means that the overlay\r\n      // is vertically centered on the origin point.\r\n      const smallestDistanceToViewportEdge =\r\n          Math.min(viewport.bottom - origin.y, origin.y - viewport.left);\r\n      const previousHeight = this._lastBoundingBoxSize.height;\r\n\r\n      height = smallestDistanceToViewportEdge * 2;\r\n      top = origin.y - smallestDistanceToViewportEdge;\r\n\r\n      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\r\n        top = origin.y - (previousHeight / 2);\r\n      }\r\n    }\r\n\r\n    // The overlay is opening 'right-ward' (the content flows to the right).\r\n    const isBoundedByRightViewportEdge =\r\n        (position.overlayX === 'start' && !isRtl) ||\r\n        (position.overlayX === 'end' && isRtl);\r\n\r\n    // The overlay is opening 'left-ward' (the content flows to the left).\r\n    const isBoundedByLeftViewportEdge =\r\n        (position.overlayX === 'end' && !isRtl) ||\r\n        (position.overlayX === 'start' && isRtl);\r\n\r\n    let width, left, right;\r\n\r\n    if (isBoundedByLeftViewportEdge) {\r\n      right = viewport.right - origin.x + this._viewportMargin;\r\n      width = origin.x - viewport.left;\r\n    } else if (isBoundedByRightViewportEdge) {\r\n      left = origin.x;\r\n      width = viewport.right - origin.x;\r\n    } else {\r\n      // If neither start nor end, it means that the overlay\r\n      // is horizontally centered on the origin point.\r\n      const smallestDistanceToViewportEdge =\r\n          Math.min(viewport.right - origin.x, origin.x - viewport.top);\r\n      const previousWidth = this._lastBoundingBoxSize.width;\r\n\r\n      width = smallestDistanceToViewportEdge * 2;\r\n      left = origin.x - smallestDistanceToViewportEdge;\r\n\r\n      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\r\n        left = origin.x - (previousWidth / 2);\r\n      }\r\n    }\r\n\r\n    return {top, left, bottom, right, width, height};\r\n  }\r\n\r\n  /**\r\n   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\r\n   * origin's connection point and stetches to the bounds of the viewport.\r\n   *\r\n   * @param origin The point on the origin element where the overlay is connected.\r\n   * @param position The position preference\r\n   */\r\n  private _setBoundingBoxStyles(origin: Point, position: ConnectedPosition): void {\r\n    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\r\n\r\n    // It's weird if the overlay *grows* while scrolling, so we take the last size into account\r\n    // when applying a new size.\r\n    if (!this._isInitialRender && !this._growAfterOpen) {\r\n      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\r\n      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\r\n    }\r\n\r\n    const styles = {} as CSSStyleDeclaration;\r\n\r\n    if (this._hasExactPosition()) {\r\n      styles.top = styles.left = '0';\r\n      styles.bottom = styles.right = '';\r\n      styles.width = styles.height = '100%';\r\n    } else {\r\n      const maxHeight = this._overlayRef.getConfig().maxHeight;\r\n      const maxWidth = this._overlayRef.getConfig().maxWidth;\r\n\r\n      styles.height = coerceCssPixelValue(boundingBoxRect.height);\r\n      styles.top = coerceCssPixelValue(boundingBoxRect.top);\r\n      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\r\n      styles.width = coerceCssPixelValue(boundingBoxRect.width);\r\n      styles.left = coerceCssPixelValue(boundingBoxRect.left);\r\n      styles.right = coerceCssPixelValue(boundingBoxRect.right);\r\n\r\n      // Push the pane content towards the proper direction.\r\n      if (position.overlayX === 'center') {\r\n        styles.alignItems = 'center';\r\n      } else {\r\n        styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\r\n      }\r\n\r\n      if (position.overlayY === 'center') {\r\n        styles.justifyContent = 'center';\r\n      } else {\r\n        styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\r\n      }\r\n\r\n      if (maxHeight) {\r\n        styles.maxHeight = coerceCssPixelValue(maxHeight);\r\n      }\r\n\r\n      if (maxWidth) {\r\n        styles.maxWidth = coerceCssPixelValue(maxWidth);\r\n      }\r\n    }\r\n\r\n    this._lastBoundingBoxSize = boundingBoxRect;\r\n\r\n    extendStyles(this._boundingBox!.style, styles);\r\n  }\r\n\r\n  /** Resets the styles for the bounding box so that a new positioning can be computed. */\r\n  private _resetBoundingBoxStyles() {\r\n    extendStyles(this._boundingBox!.style, {\r\n      top: '0',\r\n      left: '0',\r\n      right: '0',\r\n      bottom: '0',\r\n      height: '',\r\n      width: '',\r\n      alignItems: '',\r\n      justifyContent: '',\r\n    } as CSSStyleDeclaration);\r\n  }\r\n\r\n  /** Resets the styles for the overlay pane so that a new positioning can be computed. */\r\n  private _resetOverlayElementStyles() {\r\n    extendStyles(this._pane.style, {\r\n      top: '',\r\n      left: '',\r\n      bottom: '',\r\n      right: '',\r\n      position: '',\r\n    } as CSSStyleDeclaration);\r\n  }\r\n\r\n  /** Sets positioning styles to the overlay element. */\r\n  private _setOverlayElementStyles(originPoint: Point, position: ConnectedPosition): void {\r\n    const styles = {} as CSSStyleDeclaration;\r\n\r\n    if (this._hasExactPosition()) {\r\n      extendStyles(styles, this._getExactOverlayY(position, originPoint));\r\n      extendStyles(styles, this._getExactOverlayX(position, originPoint));\r\n    } else {\r\n      styles.position = 'static';\r\n    }\r\n\r\n    // Use a transform to apply the offsets. We do this because the `center` positions rely on\r\n    // being in the normal flex flow and setting a `top` / `left` at all will completely throw\r\n    // off the position. We also can't use margins, because they won't have an effect in some\r\n    // cases where the element doesn't have anything to \"push off of\". Finally, this works\r\n    // better both with flexible and non-flexible positioning.\r\n    let transformString = '';\r\n    let offsetX = this._getOffset(position, 'x');\r\n    let offsetY = this._getOffset(position, 'y');\r\n\r\n    if (offsetX) {\r\n      transformString += `translateX(${offsetX}px) `;\r\n    }\r\n\r\n    if (offsetY) {\r\n      transformString += `translateY(${offsetY}px)`;\r\n    }\r\n\r\n    styles.transform = transformString.trim();\r\n\r\n    // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\r\n    // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\r\n    // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\r\n    if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {\r\n      styles.maxHeight = '';\r\n    }\r\n\r\n    if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {\r\n      styles.maxWidth = '';\r\n    }\r\n\r\n    extendStyles(this._pane.style, styles);\r\n  }\r\n\r\n  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\r\n  private _getExactOverlayY(position: ConnectedPosition, originPoint: Point) {\r\n    // Reset any existing styles. This is necessary in case the\r\n    // preferred position has changed since the last `apply`.\r\n    let styles = {top: null, bottom: null} as CSSStyleDeclaration;\r\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\r\n\r\n    if (this._isPushed) {\r\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect);\r\n    }\r\n\r\n    // @breaking-change 7.0.0 Currently the `_overlayContainer` is optional in order to avoid a\r\n    // breaking change. The null check here can be removed once the `_overlayContainer` becomes\r\n    // a required parameter.\r\n    let virtualKeyboardOffset = this._overlayContainer ?\r\n        this._overlayContainer.getContainerElement().getBoundingClientRect().top : 0;\r\n\r\n    // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\r\n    // autocomplete), mobile browsers will shift everything in order to put the input in the middle\r\n    // of the screen and to make space for the virtual keyboard. We need to account for this offset,\r\n    // otherwise our positioning will be thrown off.\r\n    overlayPoint.y -= virtualKeyboardOffset;\r\n\r\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear\r\n    // above or below the origin and the direction in which the element will expand.\r\n    if (position.overlayY === 'bottom') {\r\n      // When using `bottom`, we adjust the y position such that it is the distance\r\n      // from the bottom of the viewport rather than the top.\r\n      const documentHeight = this._document.documentElement.clientHeight;\r\n      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\r\n    } else {\r\n      styles.top = coerceCssPixelValue(overlayPoint.y);\r\n    }\r\n\r\n    return styles;\r\n  }\r\n\r\n  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\r\n  private _getExactOverlayX(position: ConnectedPosition, originPoint: Point) {\r\n    // Reset any existing styles. This is necessary in case the preferred position has\r\n    // changed since the last `apply`.\r\n    let styles = {left: null, right: null} as CSSStyleDeclaration;\r\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\r\n\r\n    if (this._isPushed) {\r\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect);\r\n    }\r\n\r\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\r\n    // or \"after\" the origin, which determines the direction in which the element will expand.\r\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\r\n    // page is in RTL or LTR.\r\n    let horizontalStyleProperty: 'left' | 'right';\r\n\r\n    if (this._isRtl()) {\r\n      horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\r\n    } else {\r\n      horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\r\n    }\r\n\r\n    // When we're setting `right`, we adjust the x position such that it is the distance\r\n    // from the right edge of the viewport rather than the left edge.\r\n    if (horizontalStyleProperty === 'right') {\r\n      const documentWidth = this._document.documentElement.clientWidth;\r\n      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\r\n    } else {\r\n      styles.left = coerceCssPixelValue(overlayPoint.x);\r\n    }\r\n\r\n    return styles;\r\n  }\r\n\r\n  /**\r\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\r\n   * or completely outside the view of any of the strategy's scrollables.\r\n   */\r\n  private _getScrollVisibility(): ScrollingVisibility {\r\n    // Note: needs fresh rects since the position could've changed.\r\n    const originBounds = this._origin.getBoundingClientRect();\r\n    const overlayBounds =  this._pane.getBoundingClientRect();\r\n\r\n    // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\r\n    // every time, we should be able to use the scrollTop of the containers if the size of those\r\n    // containers hasn't changed.\r\n    const scrollContainerBounds = this.scrollables.map(scrollable => {\r\n      return scrollable.getElementRef().nativeElement.getBoundingClientRect();\r\n    });\r\n\r\n    return {\r\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\r\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\r\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\r\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\r\n    };\r\n  }\r\n\r\n  /** Subtracts the amount that an element is overflowing on an axis from it's length. */\r\n  private _subtractOverflows(length: number, ...overflows: number[]): number {\r\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\r\n      return currentValue - Math.max(currentOverflow, 0);\r\n    }, length);\r\n  }\r\n\r\n  /** Narrows the given viewport rect by the current _viewportMargin. */\r\n  private _getNarrowedViewportRect(): ClientRect {\r\n    // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\r\n    // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\r\n    // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\r\n    // and `innerHeight` that do. This is necessary, because the overlay container uses\r\n    // 100% `width` and `height` which don't include the scrollbar either.\r\n    const width = this._document.documentElement.clientWidth;\r\n    const height = this._document.documentElement.clientHeight;\r\n    const scrollPosition = this._viewportRuler.getViewportScrollPosition();\r\n\r\n    return {\r\n      top:    scrollPosition.top + this._viewportMargin,\r\n      left:   scrollPosition.left + this._viewportMargin,\r\n      right:  scrollPosition.left + width - this._viewportMargin,\r\n      bottom: scrollPosition.top + height - this._viewportMargin,\r\n      width:  width  - (2 * this._viewportMargin),\r\n      height: height - (2 * this._viewportMargin),\r\n    };\r\n  }\r\n\r\n  /** Whether the we're dealing with an RTL context */\r\n  private _isRtl() {\r\n    return this._overlayRef.getDirection() === 'rtl';\r\n  }\r\n\r\n  /** Determines whether the overlay uses exact or flexible positioning. */\r\n  private _hasExactPosition() {\r\n    return !this._hasFlexibleDimensions || this._isPushed;\r\n  }\r\n\r\n  /** Retrieves the offset of a position along the x or y axis. */\r\n  private _getOffset(position: ConnectedPosition, axis: 'x' | 'y') {\r\n    if (axis === 'x') {\r\n      // We don't do something like `position['offset' + axis]` in\r\n      // order to avoid breking minifiers that rename properties.\r\n      return position.offsetX == null ? this._offsetX : position.offsetX;\r\n    }\r\n\r\n    return position.offsetY == null ? this._offsetY : position.offsetY;\r\n  }\r\n\r\n  /** Validates that the current position match the expected values. */\r\n  private _validatePositions(): void {\r\n    if (!this._preferredPositions.length) {\r\n      throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\r\n    }\r\n\r\n    // TODO(crisbeto): remove these once Angular's template type\r\n    // checking is advanced enough to catch these cases.\r\n    this._preferredPositions.forEach(pair => {\r\n      validateHorizontalPosition('originX', pair.originX);\r\n      validateVerticalPosition('originY', pair.originY);\r\n      validateHorizontalPosition('overlayX', pair.overlayX);\r\n      validateVerticalPosition('overlayY', pair.overlayY);\r\n    });\r\n  }\r\n}\r\n\r\n/** A simple (x, y) coordinate. */\r\ninterface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n/** Record of measurements for how an overlay (at a given position) fits into the viewport. */\r\ninterface OverlayFit {\r\n  /** Whether the overlay fits completely in the viewport. */\r\n  isCompletelyWithinViewport: boolean;\r\n\r\n  /** Whether the overlay fits in the viewport on the y-axis. */\r\n  fitsInViewportVertically: boolean;\r\n\r\n  /** Whether the overlay fits in the viewport on the x-axis. */\r\n  fitsInViewportHorizontally: boolean;\r\n\r\n  /** The total visible area (in px^2) of the overlay inside the viewport. */\r\n  visibleArea: number;\r\n}\r\n\r\n/** Record of the measurments determining whether an overlay will fit in a specific position. */\r\ninterface FallbackPosition {\r\n  position: ConnectedPosition;\r\n  originPoint: Point;\r\n  overlayPoint: Point;\r\n  overlayFit: OverlayFit;\r\n  overlayRect: ClientRect;\r\n}\r\n\r\n/** Position and size of the overlay sizing wrapper for a specific position. */\r\ninterface BoundingBoxRect {\r\n  top: number;\r\n  left: number;\r\n  bottom: number;\r\n  right: number;\r\n  height: number;\r\n  width: number;\r\n}\r\n\r\n/** Record of measures determining how well a given position will fit with flexible dimensions. */\r\ninterface FlexibleFit {\r\n  position: ConnectedPosition;\r\n  origin: Point;\r\n  overlayRect: ClientRect;\r\n  boundingBoxRect: BoundingBoxRect;\r\n}\r\n\r\n/** A connected position as specified by the user. */\r\nexport interface ConnectedPosition {\r\n  originX: 'start' | 'center' | 'end';\r\n  originY: 'top' | 'center' | 'bottom';\r\n\r\n  overlayX: 'start' | 'center' | 'end';\r\n  overlayY: 'top' | 'center' | 'bottom';\r\n\r\n  weight?: number;\r\n  offsetX?: number;\r\n  offsetY?: number;\r\n}\r\n\r\n/** Shallow-extends a stylesheet object with another stylesheet object. */\r\nfunction extendStyles(dest: CSSStyleDeclaration, source: CSSStyleDeclaration): CSSStyleDeclaration {\r\n  for (let key in source) {\r\n    if (source.hasOwnProperty(key)) {\r\n      dest[key] = source[key];\r\n    }\r\n  }\r\n\r\n  return dest;\r\n}\r\n"]}