{"version":3,"file":"can-stick.js","sourceRoot":"","sources":["../../../../../src/cdk/table/can-stick.ts"],"names":[],"mappings":";;;;;;;;;;;;AAQA,OAAO,EAAC,qBAAqB,EAAC,MAAM,uBAAuB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8B5D,MAAM,8BAAyD,IAAO;IAEpE,MAAM;QAAe,mCAAI;QAyBvB;YAAY,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAA1B,+BAAuC,IAAI,UAAI;4BAjB5B,KAAK;;;;sCAGK,KAAK;;SAca;QAvB/C,sBAAI,2BAAM;YADV,oDAAoD;;;;;YACpD,cAAwB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;;;;;YAC9C,UAAW,CAAU;gBACnB,qBAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC;gBAC/B,IAAI,CAAC,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;gBACxC,IAAI,CAAC,iBAAiB,GAAG,SAAS,KAAK,IAAI,CAAC,OAAO,CAAC;aACrD;;;WAL6C;QAW9C,uEAAuE;;;;;QACvE,kCAAgB;;;;QAAhB;YACE,qBAAM,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC;YAChD,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;YAC/B,MAAM,CAAC,gBAAgB,CAAC;SACzB;QAED,8FAA8F;;;;;QAC9F,oCAAkB;;;;QAAlB;YACE,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;SAChC;sBA/DL;KAkEG,AA1BM,CAAc,IAAI,GA0BvB;CACH","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\r\n\r\n/** @docs-private */\r\nexport type Constructor<T> = new(...args: any[]) => T;\r\n\r\n/**\r\n * Interface for a mixin to provide a directive with a function that checks if the sticky input has\r\n * been changed since the last time the function was called. Essentially adds a dirty-check to the\r\n * sticky value.\r\n * @docs-private\r\n */\r\nexport interface CanStick {\r\n  /** Whether sticky positioning should be applied. */\r\n  sticky: boolean;\r\n\r\n  /** Whether the sticky input has changed since it was last checked. */\r\n  _hasStickyChanged: boolean;\r\n\r\n  /** Whether the sticky value has changed since this was last called. */\r\n  hasStickyChanged(): boolean;\r\n\r\n  /** Resets the dirty check for cases where the sticky state has been used without checking. */\r\n  resetStickyChanged(): void;\r\n}\r\n\r\n/**\r\n * Mixin to provide a directive with a function that checks if the sticky input has been\r\n * changed since the last time the function was called. Essentially adds a dirty-check to the\r\n * sticky value.\r\n */\r\nexport function mixinHasStickyInput<T extends Constructor<{}>>(base: T):\r\n    Constructor<CanStick> & T {\r\n  return class extends base {\r\n    /** Whether sticky positioning should be applied. */\r\n    get sticky(): boolean { return this._sticky; }\r\n    set sticky(v: boolean) {\r\n      const prevValue = this._sticky;\r\n      this._sticky = coerceBooleanProperty(v);\r\n      this._hasStickyChanged = prevValue !== this._sticky;\r\n    }\r\n    _sticky: boolean = false;\r\n\r\n    /** Whether the sticky input has changed since it was last checked. */\r\n    _hasStickyChanged: boolean = false;\r\n\r\n    /** Whether the sticky value has changed since this was last called. */\r\n    hasStickyChanged(): boolean {\r\n      const hasStickyChanged = this._hasStickyChanged;\r\n      this._hasStickyChanged = false;\r\n      return hasStickyChanged;\r\n    }\r\n\r\n    /** Resets the dirty check for cases where the sticky state has been used without checking. */\r\n    resetStickyChanged() {\r\n      this._hasStickyChanged = false;\r\n    }\r\n\r\n    constructor(...args: any[]) { super(...args); }\r\n  };\r\n}\r\n"]}