{"version":3,"file":"flat-tree-control.js","sourceRoot":"","sources":["../../../../../../src/cdk/tree/control/flat-tree-control.ts"],"names":[],"mappings":";;;;;;;;;;;;AAQA,OAAO,EAAC,eAAe,EAAC,MAAM,qBAAqB,CAAC;;;;;AAGpD;;;;AAAA;IAAwC,2CAAkB;IAExD,8EAA8E;IAC9E,yBAAmB,QAAiC,EACjC;QADnB,YAEE,iBAAO,SACR;QAHkB,cAAQ,GAAR,QAAQ,CAAyB;QACjC,kBAAY,GAAZ,YAAY;;KAE9B;IAED;;;;;OAKG;;;;;;;;;IACH,wCAAc;;;;;;;;IAAd,UAAe,QAAW;QACxB,qBAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACpD,qBAAM,OAAO,GAAQ,EAAE,CAAC;;;;;;;QAQxB,GAAG,CAAC,CAAC,qBAAI,CAAC,GAAG,UAAU,GAAG,CAAC,EACvB,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EACvF,CAAC,EAAE,EAAE,CAAC;YACR,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;SACjC;QACD,MAAM,CAAC,OAAO,CAAC;KAChB;IAED;;;;;OAKG;;;;;;;;IACH,mCAAS;;;;;;;IAAT;QACE,CAAA,KAAA,IAAI,CAAC,cAAc,CAAA,CAAC,MAAM,WAAI,IAAI,CAAC,SAAS,EAAE;;KAC/C;0BAnDH;EAWwC,eAAe,EAyCtD,CAAA;;;;;AAzCD,2BAyCC","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {BaseTreeControl} from './base-tree-control';\r\n\r\n/** Flat tree control. Able to expand/collapse a subtree recursively for flattened tree. */\r\nexport class FlatTreeControl<T> extends BaseTreeControl<T> {\r\n\r\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\r\n  constructor(public getLevel: (dataNode: T) => number,\r\n              public isExpandable: (dataNode: T) => boolean) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Gets a list of the data node's subtree of descendent data nodes.\r\n   *\r\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\r\n   * with correct levels.\r\n   */\r\n  getDescendants(dataNode: T): T[] {\r\n    const startIndex = this.dataNodes.indexOf(dataNode);\r\n    const results: T[] = [];\r\n\r\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\r\n    // The level of descendants of a tree node must be greater than the level of the given\r\n    // tree node.\r\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\r\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\r\n    // sibling of an ancestor.\r\n    for (let i = startIndex + 1;\r\n        i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]);\r\n        i++) {\r\n      results.push(this.dataNodes[i]);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Expands all data nodes in the tree.\r\n   *\r\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\r\n   * data nodes of the tree.\r\n   */\r\n  expandAll(): void {\r\n    this.expansionModel.select(...this.dataNodes);\r\n  }\r\n}\r\n"]}