{"version":3,"file":"autofill.js","sourceRoot":"","sources":["../../../../src/cdk/text-field/autofill.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {Platform, supportsPassiveEventListeners} from '@angular/cdk/platform';\r\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Injectable,\r\n  NgZone,\r\n  OnDestroy,\r\n  OnInit,\r\n  Output,\r\n} from '@angular/core';\r\nimport {EMPTY, Observable, Subject} from 'rxjs';\r\n\r\n\r\n/** An event that is emitted when the autofill state of an input changes. */\r\nexport type AutofillEvent = {\r\n  /** The element whose autofill state changes. */\r\n  target: Element;\r\n  /** Whether the element is currently autofilled. */\r\n  isAutofilled: boolean;\r\n};\r\n\r\n\r\n/** Used to track info about currently monitored elements. */\r\ntype MonitoredElementInfo = {\r\n  subject: Subject<AutofillEvent>;\r\n  unlisten: () => void;\r\n};\r\n\r\n\r\n/** Options to pass to the animationstart listener. */\r\nconst listenerOptions: any = supportsPassiveEventListeners() ? {passive: true} : false;\r\n\r\n\r\n/**\r\n * An injectable service that can be used to monitor the autofill state of an input.\r\n * Based on the following blog post:\r\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\r\n */\r\n@Injectable({providedIn: 'root'})\r\nexport class AutofillMonitor implements OnDestroy {\r\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\r\n\r\n  constructor(private _platform: Platform, private _ngZone: NgZone) {}\r\n\r\n  /**\r\n   * Monitor for changes in the autofill state of the given input element.\r\n   * @param element The element to monitor.\r\n   * @return A stream of autofill state changes.\r\n   */\r\n  monitor(element: Element): Observable<AutofillEvent> {\r\n    if (!this._platform.isBrowser) {\r\n      return EMPTY;\r\n    }\r\n\r\n    const info = this._monitoredElements.get(element);\r\n\r\n    if (info) {\r\n      return info.subject.asObservable();\r\n    }\r\n\r\n    const result = new Subject<AutofillEvent>();\r\n    const cssClass = 'cdk-text-field-autofilled';\r\n    const listener = (event: AnimationEvent) => {\r\n      // Animation events fire on initial element render, we check for the presence of the autofill\r\n      // CSS class to make sure this is a real change in state, not just the initial render before\r\n      // we fire off events.\r\n      if (event.animationName === 'cdk-text-field-autofill-start' &&\r\n          !element.classList.contains(cssClass)) {\r\n        element.classList.add(cssClass);\r\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: true}));\r\n      } else if (event.animationName === 'cdk-text-field-autofill-end' &&\r\n          element.classList.contains(cssClass)) {\r\n        element.classList.remove(cssClass);\r\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: false}));\r\n      }\r\n    };\r\n\r\n    this._ngZone.runOutsideAngular(() => {\r\n      element.addEventListener('animationstart', listener, listenerOptions);\r\n      element.classList.add('cdk-text-field-autofill-monitored');\r\n    });\r\n\r\n    this._monitoredElements.set(element, {\r\n      subject: result,\r\n      unlisten: () => {\r\n        element.removeEventListener('animationstart', listener, listenerOptions);\r\n      }\r\n    });\r\n\r\n    return result.asObservable();\r\n  }\r\n\r\n  /**\r\n   * Stop monitoring the autofill state of the given input element.\r\n   * @param element The element to stop monitoring.\r\n   */\r\n  stopMonitoring(element: Element) {\r\n    const info = this._monitoredElements.get(element);\r\n\r\n    if (info) {\r\n      info.unlisten();\r\n      info.subject.complete();\r\n      element.classList.remove('cdk-text-field-autofill-monitored');\r\n      element.classList.remove('cdk-text-field-autofilled');\r\n      this._monitoredElements.delete(element);\r\n    }\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\r\n  }\r\n}\r\n\r\n\r\n/** A directive that can be used to monitor the autofill state of an input. */\r\n@Directive({\r\n  selector: '[cdkAutofill]',\r\n})\r\nexport class CdkAutofill implements OnDestroy, OnInit {\r\n  /** Emits when the autofill state of the element changes. */\r\n  @Output() cdkAutofill: EventEmitter<AutofillEvent> = new EventEmitter<AutofillEvent>();\r\n\r\n  constructor(private _elementRef: ElementRef, private _autofillMonitor: AutofillMonitor) {}\r\n\r\n  ngOnInit() {\r\n    this._autofillMonitor\r\n      .monitor(this._elementRef.nativeElement)\r\n      .subscribe(event => this.cdkAutofill.emit(event));\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\r\n  }\r\n}\r\n"]}