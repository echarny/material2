{"version":3,"file":"drop.js","sourceRoot":"","sources":["../../../../../src/cdk-experimental/drag-drop/drop.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {\r\n  ChangeDetectionStrategy,\r\n  Component,\r\n  ContentChildren,\r\n  ElementRef,\r\n  EventEmitter,\r\n  forwardRef,\r\n  Input,\r\n  OnDestroy,\r\n  OnInit,\r\n  Output,\r\n  QueryList,\r\n  ViewEncapsulation,\r\n} from '@angular/core';\r\nimport {CdkDrag} from './drag';\r\nimport {CdkDragExit, CdkDragEnter, CdkDragDrop} from './drag-events';\r\nimport {CDK_DROP_CONTAINER} from './drop-container';\r\nimport {DragDropRegistry} from './drag-drop-registry';\r\n\r\n/** Counter used to generate unique ids for drop zones. */\r\nlet _uniqueIdCounter = 0;\r\n\r\n/** Container that wraps a set of draggable items. */\r\n@Component({\r\n  moduleId: module.id,\r\n  selector: 'cdk-drop',\r\n  exportAs: 'cdkDrop',\r\n  template: '<ng-content></ng-content>',\r\n  encapsulation: ViewEncapsulation.None,\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  styleUrls: ['drop.css'],\r\n  providers: [\r\n    {provide: CDK_DROP_CONTAINER, useExisting: CdkDrop},\r\n  ],\r\n  host: {\r\n    'class': 'cdk-drop',\r\n    '[id]': 'id',\r\n    '[class.cdk-drop-dragging]': '_dragging'\r\n  }\r\n})\r\nexport class CdkDrop<T = any> implements OnInit, OnDestroy {\r\n  /** Draggable items in the container. */\r\n  @ContentChildren(forwardRef(() => CdkDrag)) _draggables: QueryList<CdkDrag>;\r\n\r\n  /**\r\n   * Other draggable containers that this container is connected to and into which the\r\n   * container's items can be transferred. Can either be references to other drop containers,\r\n   * or their unique IDs.\r\n   */\r\n  @Input() connectedTo: (CdkDrop | string)[] = [];\r\n\r\n  /** Arbitrary data to attach to this container. */\r\n  @Input() data: T;\r\n\r\n  /** Direction in which the list is oriented. */\r\n  @Input() orientation: 'horizontal' | 'vertical' = 'vertical';\r\n\r\n  /**\r\n   * Unique ID for the drop zone. Can be used as a reference\r\n   * in the `connectedTo` of another `CdkDrop`.\r\n   */\r\n  @Input() id: string = `cdk-drop-${_uniqueIdCounter++}`;\r\n\r\n  /** Locks the position of the draggable elements inside the container along the specified axis. */\r\n  @Input() lockAxis: 'x' | 'y';\r\n\r\n  /**\r\n   * Function that is used to determine whether an item\r\n   * is allowed to be moved into a drop container.\r\n   */\r\n  @Input() enterPredicate: (drag?: CdkDrag, drop?: CdkDrop) => boolean = () => true;\r\n\r\n  /** Emits when the user drops an item inside the container. */\r\n  @Output() dropped: EventEmitter<CdkDragDrop<T, any>> = new EventEmitter<CdkDragDrop<T, any>>();\r\n\r\n  /**\r\n   * Emits when the user has moved a new drag item into this container.\r\n   */\r\n  @Output() entered: EventEmitter<CdkDragEnter<T>> = new EventEmitter<CdkDragEnter<T>>();\r\n\r\n  /**\r\n   * Emits when the user removes an item from the container\r\n   * by dragging it into another container.\r\n   */\r\n  @Output() exited: EventEmitter<CdkDragExit<T>> = new EventEmitter<CdkDragExit<T>>();\r\n\r\n  constructor(\r\n    public element: ElementRef<HTMLElement>,\r\n    private _dragDropRegistry: DragDropRegistry<CdkDrag, CdkDrop<T>>) {}\r\n\r\n  ngOnInit() {\r\n    this._dragDropRegistry.registerDropContainer(this);\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._dragDropRegistry.removeDropContainer(this);\r\n  }\r\n\r\n  /** Whether an item in the container is being dragged. */\r\n  _dragging = false;\r\n\r\n  /** Cache of the dimensions of all the items and the sibling containers. */\r\n  private _positionCache = {\r\n    items: [] as {drag: CdkDrag, clientRect: ClientRect, offset: number}[],\r\n    siblings: [] as {drop: CdkDrop, clientRect: ClientRect}[]\r\n  };\r\n\r\n  /**\r\n   * Draggable items that are currently active inside the container. Includes the items\r\n   * from `_draggables`, as well as any items that have been dragged in, but haven't\r\n   * been dropped yet.\r\n   */\r\n  private _activeDraggables: CdkDrag[];\r\n\r\n  /** Starts dragging an item. */\r\n  start(): void {\r\n    this._dragging = true;\r\n    this._activeDraggables = this._draggables.toArray();\r\n    this._cachePositions();\r\n  }\r\n\r\n  /**\r\n   * Drops an item into this container.\r\n   * @param item Item being dropped into the container.\r\n   * @param currentIndex Index at which the item should be inserted.\r\n   * @param previousContainer Container from which the item got dragged in.\r\n   */\r\n  drop(item: CdkDrag, currentIndex: number, previousContainer: CdkDrop): void {\r\n    this._reset();\r\n    this.dropped.emit({\r\n      item,\r\n      currentIndex,\r\n      previousIndex: previousContainer.getItemIndex(item),\r\n      container: this,\r\n      // TODO(crisbeto): reconsider whether to make this null if the containers are the same.\r\n      previousContainer\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Emits an event to indicate that the user moved an item into the container.\r\n   * @param item Item that was moved into the container.\r\n   * @param xOffset Position of the item along the X axis.\r\n   * @param yOffset Position of the item along the Y axis.\r\n   */\r\n  enter(item: CdkDrag, xOffset: number, yOffset: number): void {\r\n    this.entered.emit({item, container: this});\r\n    this.start();\r\n\r\n    // We use the coordinates of where the item entered the drop\r\n    // zone to figure out at which index it should be inserted.\r\n    const newIndex = this._getItemIndexFromPointerPosition(item, xOffset, yOffset);\r\n    const currentIndex = this._activeDraggables.indexOf(item);\r\n    const newPositionReference = this._activeDraggables[newIndex];\r\n    const placeholder = item.getPlaceholderElement();\r\n\r\n    // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\r\n    // into another container and back again), we have to ensure that it isn't duplicated.\r\n    if (currentIndex > -1) {\r\n      this._activeDraggables.splice(currentIndex, 1);\r\n    }\r\n\r\n    // Don't use items that are being dragged as a reference, because\r\n    // their element has been moved down to the bottom of the body.\r\n    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\r\n      const element = newPositionReference.element.nativeElement;\r\n      element.parentElement!.insertBefore(placeholder, element);\r\n      this._activeDraggables.splice(newIndex, 0, item);\r\n    } else {\r\n      this.element.nativeElement.appendChild(placeholder);\r\n      this._activeDraggables.push(item);\r\n    }\r\n\r\n    // The transform needs to be cleared so it doesn't throw off the measurements.\r\n    placeholder.style.transform = '';\r\n\r\n    // Note that the positions were already cached when we called `start` above,\r\n    // but we need to refresh them since the amount of items has changed.\r\n    this._cachePositions();\r\n  }\r\n\r\n  /**\r\n   * Removes an item from the container after it was dragged into another container by the user.\r\n   * @param item Item that was dragged out.\r\n   */\r\n  exit(item: CdkDrag): void {\r\n    this._reset();\r\n    this.exited.emit({item, container: this});\r\n  }\r\n\r\n  /**\r\n   * Figures out the index of an item in the container.\r\n   * @param item Item whose index should be determined.\r\n   */\r\n  getItemIndex(item: CdkDrag): number {\r\n    return this._dragging ?\r\n        this._positionCache.items.findIndex(currentItem => currentItem.drag === item) :\r\n        this._draggables.toArray().indexOf(item);\r\n  }\r\n\r\n  /**\r\n   * Sorts an item inside the container based on its position.\r\n   * @param item Item to be sorted.\r\n   * @param xOffset Position of the item along the X axis.\r\n   * @param yOffset Position of the item along the Y axis.\r\n   */\r\n  _sortItem(item: CdkDrag, xOffset: number, yOffset: number): void {\r\n    const siblings = this._positionCache.items;\r\n    const isHorizontal = this.orientation === 'horizontal';\r\n    const newIndex = this._getItemIndexFromPointerPosition(item, xOffset, yOffset);\r\n    const placeholder = item.getPlaceholderElement();\r\n\r\n    if (newIndex === -1 && siblings.length > 0) {\r\n      return;\r\n    }\r\n\r\n    const currentIndex = siblings.findIndex(currentItem => currentItem.drag === item);\r\n    const currentPosition = siblings[currentIndex];\r\n    const newPosition = siblings[newIndex];\r\n\r\n    // Figure out the offset necessary for the items to be swapped.\r\n    const offset = isHorizontal ?\r\n        currentPosition.clientRect.left - newPosition.clientRect.left :\r\n        currentPosition.clientRect.top - newPosition.clientRect.top;\r\n    const topAdjustment = isHorizontal ? 0 : offset;\r\n    const leftAdjustment = isHorizontal ? offset : 0;\r\n\r\n    // Since we've moved the items with a `transform`, we need to adjust their cached\r\n    // client rects to reflect their new position, as well as swap their positions in the cache.\r\n    // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\r\n    // elements may be mid-animation which will give us a wrong result.\r\n    this._adjustClientRect(currentPosition.clientRect, -topAdjustment, -leftAdjustment);\r\n    currentPosition.offset -= offset;\r\n    siblings[currentIndex] = newPosition;\r\n\r\n    this._adjustClientRect(newPosition.clientRect, topAdjustment, leftAdjustment);\r\n    newPosition.offset += offset;\r\n    siblings[newIndex] = currentPosition;\r\n\r\n    // Swap the placeholder's position with the one of the target draggable.\r\n    placeholder.style.transform = isHorizontal ?\r\n        `translate3d(${currentPosition.offset}px, 0, 0)` :\r\n        `translate3d(0, ${currentPosition.offset}px, 0)`;\r\n\r\n    newPosition.drag.element.nativeElement.style.transform = isHorizontal ?\r\n        `translate3d(${newPosition.offset}px, 0, 0)` :\r\n        `translate3d(0, ${newPosition.offset}px, 0)`;\r\n  }\r\n\r\n  /**\r\n   * Figures out whether an item should be moved into a sibling\r\n   * drop container, based on its current position.\r\n   * @param item Drag item that is being moved.\r\n   * @param x Position of the item along the X axis.\r\n   * @param y Position of the item along the Y axis.\r\n   */\r\n  _getSiblingContainerFromPosition(item: CdkDrag, x: number, y: number): CdkDrop | null {\r\n    const result = this._positionCache.siblings.find(({clientRect}) => {\r\n      const {top, bottom, left, right} = clientRect;\r\n      return y >= top && y <= bottom && x >= left && x <= right;\r\n    });\r\n\r\n    return result && result.drop.enterPredicate(item, this) ? result.drop : null;\r\n  }\r\n\r\n  /** Refreshes the position cache of the items and sibling containers. */\r\n  private _cachePositions() {\r\n    this._positionCache.items = this._activeDraggables\r\n      .map(drag => {\r\n        const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\r\n            // If the element is being dragged, we have to measure the\r\n            // placeholder, because the element is hidden.\r\n            drag.getPlaceholderElement() :\r\n            drag.element.nativeElement;\r\n        const clientRect = elementToMeasure.getBoundingClientRect();\r\n\r\n        return {\r\n          drag,\r\n          offset: 0,\r\n          // We need to clone the `clientRect` here, because all the values on it are readonly\r\n          // and we need to be able to update them. Also we can't use a spread here, because\r\n          // the values on a `ClientRect` aren't own properties. See:\r\n          // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\r\n          clientRect: {\r\n            top: clientRect.top,\r\n            right: clientRect.right,\r\n            bottom: clientRect.bottom,\r\n            left: clientRect.left,\r\n            width: clientRect.width,\r\n            height: clientRect.height\r\n          }\r\n        };\r\n      })\r\n      .sort((a, b) => a.clientRect.top - b.clientRect.top);\r\n\r\n    this._positionCache.siblings = this.connectedTo\r\n      .map(drop => typeof drop === 'string' ? this._dragDropRegistry.getDropContainer(drop)! : drop)\r\n      .filter(drop => drop && drop !== this)\r\n      .map(drop => ({drop, clientRect: drop.element.nativeElement.getBoundingClientRect()}));\r\n  }\r\n\r\n  /** Resets the container to its initial state. */\r\n  private _reset() {\r\n    this._dragging = false;\r\n\r\n    // TODO(crisbeto): may have to wait for the animations to finish.\r\n    this._activeDraggables.forEach(item => item.element.nativeElement.style.transform = '');\r\n    this._activeDraggables = [];\r\n    this._positionCache.items = [];\r\n    this._positionCache.siblings = [];\r\n  }\r\n\r\n  /**\r\n   * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\r\n   * @param clientRect `ClientRect` that should be updated.\r\n   * @param top New value for the `top` position.\r\n   * @param left New value for the `left` position.\r\n   */\r\n  private _adjustClientRect(clientRect: ClientRect, top: number, left: number) {\r\n    clientRect.top += top;\r\n    clientRect.bottom = clientRect.top + clientRect.height;\r\n\r\n    clientRect.left += left;\r\n    clientRect.right = clientRect.left + clientRect.width;\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an item in the drop container, based on the position of the user's pointer.\r\n   * @param item Item that is being sorted.\r\n   * @param xOffset Position of the user's pointer along the X axis.\r\n   * @param yOffset Position of the user's pointer along the Y axis.\r\n   */\r\n  private _getItemIndexFromPointerPosition(item: CdkDrag, xOffset: number, yOffset: number) {\r\n    return this._positionCache.items.findIndex(({drag, clientRect}, _, array) => {\r\n      if (drag === item) {\r\n        // If there's only one item left in the container, it must be\r\n        // the dragged item itself so we use it as a reference.\r\n        return array.length < 2;\r\n      }\r\n\r\n      return this.orientation === 'horizontal' ?\r\n          // Round these down since most browsers report client rects with\r\n          // sub-pixel precision, whereas the mouse coordinates are rounded to pixels.\r\n          xOffset >= Math.floor(clientRect.left) && xOffset <= Math.floor(clientRect.right) :\r\n          yOffset >= Math.floor(clientRect.top) && yOffset <= Math.floor(clientRect.bottom);\r\n    });\r\n  }\r\n}\r\n"]}