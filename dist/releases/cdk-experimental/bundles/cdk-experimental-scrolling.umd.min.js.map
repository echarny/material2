{"version":3,"file":"cdk-experimental-scrolling.umd.min.js","sources":["../../src/cdk-experimental/scrolling/auto-size-virtual-scroll.ts","../../src/cdk-experimental/scrolling/scrolling-module.ts"],"sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\r\nimport {ListRange} from '@angular/cdk/collections';\r\nimport {\r\n  CdkVirtualScrollViewport,\r\n  VIRTUAL_SCROLL_STRATEGY,\r\n  VirtualScrollStrategy\r\n} from '@angular/cdk/scrolling';\r\nimport {Directive, forwardRef, Input, OnChanges} from '@angular/core';\r\nimport {Observable} from 'rxjs';\r\n\r\n\r\n/**\r\n * A class that tracks the size of items that have been seen and uses it to estimate the average\r\n * item size.\r\n */\r\nexport class ItemSizeAverager {\r\n  /** The total amount of weight behind the current average. */\r\n  private _totalWeight = 0;\r\n\r\n  /** The current average item size. */\r\n  private _averageItemSize: number;\r\n\r\n  /** The default size to use for items when no data is available. */\r\n  private _defaultItemSize: number;\r\n\r\n  /** @param defaultItemSize The default size to use for items when no data is available. */\r\n  constructor(defaultItemSize = 50) {\r\n    this._defaultItemSize = defaultItemSize;\r\n    this._averageItemSize = defaultItemSize;\r\n  }\r\n\r\n  /** Returns the average item size. */\r\n  getAverageItemSize(): number {\r\n    return this._averageItemSize;\r\n  }\r\n\r\n  /**\r\n   * Adds a measurement sample for the estimator to consider.\r\n   * @param range The measured range.\r\n   * @param size The measured size of the given range in pixels.\r\n   */\r\n  addSample(range: ListRange, size: number) {\r\n    const newTotalWeight = this._totalWeight + range.end - range.start;\r\n    if (newTotalWeight) {\r\n      const newAverageItemSize =\r\n          (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\r\n      if (newAverageItemSize) {\r\n        this._averageItemSize = newAverageItemSize;\r\n        this._totalWeight = newTotalWeight;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Resets the averager. */\r\n  reset() {\r\n    this._averageItemSize = this._defaultItemSize;\r\n    this._totalWeight = 0;\r\n  }\r\n}\r\n\r\n\r\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\r\nexport class AutoSizeVirtualScrollStrategy implements VirtualScrollStrategy {\r\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n  scrolledIndexChange = Observable.create(() => {\r\n    // TODO(mmalerba): Implement.\r\n    throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\r\n        ' autosize scroll strategy');\r\n  });\r\n\r\n  /** The attached viewport. */\r\n  private _viewport: CdkVirtualScrollViewport | null = null;\r\n\r\n  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\r\n  private _minBufferPx: number;\r\n\r\n  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\r\n  private _maxBufferPx: number;\r\n\r\n  /** The estimator used to estimate the size of unseen items. */\r\n  private _averager: ItemSizeAverager;\r\n\r\n  /** The last measured scroll offset of the viewport. */\r\n  private _lastScrollOffset: number;\r\n\r\n  /** The last measured size of the rendered content in the viewport. */\r\n  private _lastRenderedContentSize: number;\r\n\r\n  /** The last measured size of the rendered content in the viewport. */\r\n  private _lastRenderedContentOffset: number;\r\n\r\n  /**\r\n   * The number of consecutive cycles where removing extra items has failed. Failure here means that\r\n   * we estimated how many items we could safely remove, but our estimate turned out to be too much\r\n   * and it wasn't safe to remove that many elements.\r\n   */\r\n  private _removalFailures = 0;\r\n\r\n  /**\r\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\r\n   *     If the amount of buffer dips below this number, more items will be rendered.\r\n   * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\r\n   *     If the actual amount turns out to be less it will not necessarily trigger an additional\r\n   *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\r\n   * @param averager The averager used to estimate the size of unseen items.\r\n   */\r\n  constructor(minBufferPx: number, maxBufferPx: number, averager = new ItemSizeAverager()) {\r\n    this._minBufferPx = minBufferPx;\r\n    this._maxBufferPx = maxBufferPx;\r\n    this._averager = averager;\r\n  }\r\n\r\n  /**\r\n   * Attaches this scroll strategy to a viewport.\r\n   * @param viewport The viewport to attach this strategy to.\r\n   */\r\n  attach(viewport: CdkVirtualScrollViewport) {\r\n    this._averager.reset();\r\n    this._viewport = viewport;\r\n    this._setScrollOffset();\r\n  }\r\n\r\n  /** Detaches this scroll strategy from the currently attached viewport. */\r\n  detach() {\r\n    this._viewport = null;\r\n  }\r\n\r\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n  onContentScrolled() {\r\n    if (this._viewport) {\r\n      this._updateRenderedContentAfterScroll();\r\n    }\r\n  }\r\n\r\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n  onDataLengthChanged() {\r\n    if (this._viewport) {\r\n      this._setScrollOffset();\r\n      this._checkRenderedContentSize();\r\n    }\r\n  }\r\n\r\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n  onContentRendered() {\r\n    if (this._viewport) {\r\n      this._checkRenderedContentSize();\r\n    }\r\n  }\r\n\r\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n  onRenderedOffsetChanged() {\r\n    if (this._viewport) {\r\n      this._checkRenderedContentOffset();\r\n    }\r\n  }\r\n\r\n  /** Scroll to the offset for the given index. */\r\n  scrollToIndex(): void {\r\n    // TODO(mmalerba): Implement.\r\n    throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize'\r\n        + ' scroll strategy');\r\n  }\r\n\r\n  /**\r\n   * Update the buffer parameters.\r\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\r\n   * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\r\n   *     pixels).\r\n   */\r\n  updateBufferSize(minBufferPx: number, maxBufferPx: number) {\r\n    if (maxBufferPx < minBufferPx) {\r\n      throw('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\r\n    }\r\n    this._minBufferPx = minBufferPx;\r\n    this._maxBufferPx = maxBufferPx;\r\n  }\r\n\r\n  /** Update the rendered content after the user scrolls. */\r\n  private _updateRenderedContentAfterScroll() {\r\n    const viewport = this._viewport!;\r\n\r\n    // The current scroll offset.\r\n    const scrollOffset = viewport.measureScrollOffset();\r\n    // The delta between the current scroll offset and the previously recorded scroll offset.\r\n    let scrollDelta = scrollOffset - this._lastScrollOffset;\r\n    // The magnitude of the scroll delta.\r\n    let scrollMagnitude = Math.abs(scrollDelta);\r\n\r\n    // The currently rendered range.\r\n    const renderedRange = viewport.getRenderedRange();\r\n\r\n    // If we're scrolling toward the top, we need to account for the fact that the predicted amount\r\n    // of content and the actual amount of scrollable space may differ. We address this by slowly\r\n    // correcting the difference on each scroll event.\r\n    let offsetCorrection = 0;\r\n    if (scrollDelta < 0) {\r\n      // The content offset we would expect based on the average item size.\r\n      const predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\r\n      // The difference between the predicted size of the unrendered content at the beginning and\r\n      // the actual available space to scroll over. We need to reduce this to zero by the time the\r\n      // user scrolls to the top.\r\n      // - 0 indicates that the predicted size and available space are the same.\r\n      // - A negative number that the predicted size is smaller than the available space.\r\n      // - A positive number indicates the predicted size is larger than the available space\r\n      const offsetDifference = predictedOffset - this._lastRenderedContentOffset;\r\n      // The amount of difference to correct during this scroll event. We calculate this as a\r\n      // percentage of the total difference based on the percentage of the distance toward the top\r\n      // that the user scrolled.\r\n      offsetCorrection = Math.round(offsetDifference *\r\n          Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\r\n\r\n      // Based on the offset correction above, we pretend that the scroll delta was bigger or\r\n      // smaller than it actually was, this way we can start to eliminate the difference.\r\n      scrollDelta = scrollDelta - offsetCorrection;\r\n      scrollMagnitude = Math.abs(scrollDelta);\r\n    }\r\n\r\n    // The current amount of buffer past the start of the viewport.\r\n    const startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\r\n    // The current amount of buffer past the end of the viewport.\r\n    const endBuffer = (this._lastRenderedContentOffset + this._lastRenderedContentSize) -\r\n        (this._lastScrollOffset + viewport.getViewportSize());\r\n    // The amount of unfilled space that should be filled on the side the user is scrolling toward\r\n    // in order to safely absorb the scroll delta.\r\n    const underscan = scrollMagnitude + this._minBufferPx -\r\n        (scrollDelta < 0 ? startBuffer : endBuffer);\r\n\r\n    // Check if there's unfilled space that we need to render new elements to fill.\r\n    if (underscan > 0) {\r\n      // Check if the scroll magnitude was larger than the viewport size. In this case the user\r\n      // won't notice a discontinuity if we just jump to the new estimated position in the list.\r\n      // However, if the scroll magnitude is smaller than the viewport the user might notice some\r\n      // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\r\n      // the same number of pixels as the scroll magnitude.\r\n      if (scrollMagnitude >= viewport.getViewportSize()) {\r\n        this._setScrollOffset();\r\n      } else {\r\n        // The number of new items to render on the side the user is scrolling towards. Rather than\r\n        // just filling the underscan space, we actually fill enough to have a buffer size of\r\n        // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\r\n        const addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) /\r\n            this._averager.getAverageItemSize()));\r\n        // The amount of filled space beyond what is necessary on the side the user is scrolling\r\n        // away from.\r\n        const overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx +\r\n            scrollMagnitude;\r\n        // The number of currently rendered items to remove on the side the user is scrolling away\r\n        // from. If removal has failed in recent cycles we are less aggressive in how much we try to\r\n        // remove.\r\n        const unboundedRemoveItems = Math.floor(\r\n            overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\r\n        const removeItems =\r\n            Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\r\n\r\n        // The new range we will tell the viewport to render. We first expand it to include the new\r\n        // items we want rendered, we then contract the opposite side to remove items we no longer\r\n        // want rendered.\r\n        const range = this._expandRange(\r\n            renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\r\n        if (scrollDelta < 0) {\r\n          range.end = Math.max(range.start + 1, range.end - removeItems);\r\n        } else {\r\n          range.start = Math.min(range.end - 1, range.start + removeItems);\r\n        }\r\n\r\n        // The new offset we want to set on the rendered content. To determine this we measure the\r\n        // number of pixels we removed and then adjust the offset to the start of the rendered\r\n        // content or to the end of the rendered content accordingly (whichever one doesn't require\r\n        // that the newly added items to be rendered to calculate.)\r\n        let contentOffset: number;\r\n        let contentOffsetTo: 'to-start' | 'to-end';\r\n        if (scrollDelta < 0) {\r\n          let removedSize = viewport.measureRangeSize({\r\n            start: range.end,\r\n            end: renderedRange.end,\r\n          });\r\n          // Check that we're not removing too much.\r\n          if (removedSize <= overscan) {\r\n            contentOffset =\r\n                this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\r\n            this._removalFailures = 0;\r\n          } else {\r\n            // If the removal is more than the overscan can absorb just undo it and record the fact\r\n            // that the removal failed so we can be less aggressive next time.\r\n            range.end = renderedRange.end;\r\n            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\r\n            this._removalFailures++;\r\n          }\r\n          contentOffsetTo = 'to-end';\r\n        } else {\r\n          const removedSize = viewport.measureRangeSize({\r\n            start: renderedRange.start,\r\n            end: range.start,\r\n          });\r\n          // Check that we're not removing too much.\r\n          if (removedSize <= overscan) {\r\n            contentOffset = this._lastRenderedContentOffset + removedSize;\r\n            this._removalFailures = 0;\r\n          } else {\r\n            // If the removal is more than the overscan can absorb just undo it and record the fact\r\n            // that the removal failed so we can be less aggressive next time.\r\n            range.start = renderedRange.start;\r\n            contentOffset = this._lastRenderedContentOffset;\r\n            this._removalFailures++;\r\n          }\r\n          contentOffsetTo = 'to-start';\r\n        }\r\n\r\n        // Set the range and offset we calculated above.\r\n        viewport.setRenderedRange(range);\r\n        viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\r\n      }\r\n    } else if (offsetCorrection) {\r\n      // Even if the rendered range didn't change, we may still need to adjust the content offset to\r\n      // simulate scrolling slightly slower or faster than the user actually scrolled.\r\n      viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\r\n    }\r\n\r\n    // Save the scroll offset to be compared to the new value on the next scroll event.\r\n    this._lastScrollOffset = scrollOffset;\r\n  }\r\n\r\n  /**\r\n   * Checks the size of the currently rendered content and uses it to update the estimated item size\r\n   * and estimated total content size.\r\n   */\r\n  private _checkRenderedContentSize() {\r\n    const viewport = this._viewport!;\r\n    this._lastRenderedContentSize = viewport.measureRenderedContentSize();\r\n    this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\r\n    this._updateTotalContentSize(this._lastRenderedContentSize);\r\n  }\r\n\r\n  /** Checks the currently rendered content offset and saves the value for later use. */\r\n  private _checkRenderedContentOffset() {\r\n    const viewport = this._viewport!;\r\n    this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart()!;\r\n  }\r\n\r\n  /**\r\n   * Sets the scroll offset and renders the content we estimate should be shown at that point.\r\n   * @param scrollOffset The offset to jump to. If not specified the scroll offset will not be\r\n   *     changed, but the rendered content will be recalculated based on our estimate of what should\r\n   *     be shown at the current scroll offset.\r\n   */\r\n  private _setScrollOffset(scrollOffset?: number) {\r\n    const viewport = this._viewport!;\r\n    if (scrollOffset == null) {\r\n      scrollOffset = viewport.measureScrollOffset();\r\n    } else {\r\n      viewport.setScrollOffset(scrollOffset);\r\n    }\r\n    this._lastScrollOffset = scrollOffset;\r\n    this._removalFailures = 0;\r\n\r\n    const itemSize = this._averager.getAverageItemSize();\r\n    const firstVisibleIndex =\r\n        Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\r\n    const bufferSize = Math.ceil(this._maxBufferPx / itemSize);\r\n    const range = this._expandRange(\r\n        this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\r\n\r\n    viewport.setRenderedRange(range);\r\n    viewport.setRenderedContentOffset(itemSize * range.start);\r\n  }\r\n\r\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\r\n  /**\r\n   * Gets the visible range of data for the given start index. If the start index is too close to\r\n   * the end of the list it may be backed up to ensure the estimated size of the range is enough to\r\n   * fill the viewport.\r\n   * Note: must not be called if `this._viewport` is null\r\n   * @param startIndex The index to start the range at\r\n   * @return a range estimated to be large enough to fill the viewport when rendered.\r\n   */\r\n  private _getVisibleRangeForIndex(startIndex: number): ListRange {\r\n    const viewport = this._viewport!;\r\n    const range: ListRange = {\r\n      start: startIndex,\r\n      end: startIndex +\r\n          Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize())\r\n    };\r\n    const extra = range.end - viewport.getDataLength();\r\n    if (extra > 0) {\r\n      range.start = Math.max(0, range.start - extra);\r\n    }\r\n    return range;\r\n  }\r\n\r\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\r\n  /**\r\n   * Expand the given range by the given amount in either direction.\r\n   * Note: must not be called if `this._viewport` is null\r\n   * @param range The range to expand\r\n   * @param expandStart The number of items to expand the start of the range by.\r\n   * @param expandEnd The number of items to expand the end of the range by.\r\n   * @return The expanded range.\r\n   */\r\n  private _expandRange(range: ListRange, expandStart: number, expandEnd: number): ListRange {\r\n    const viewport = this._viewport!;\r\n    const start = Math.max(0, range.start - expandStart);\r\n    const end = Math.min(viewport.getDataLength(), range.end + expandEnd);\r\n    return {start, end};\r\n  }\r\n\r\n  /** Update the viewport's total content size. */\r\n  private _updateTotalContentSize(renderedContentSize: number) {\r\n    const viewport = this._viewport!;\r\n    const renderedRange = viewport.getRenderedRange();\r\n    const totalSize = renderedContentSize +\r\n        (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\r\n        this._averager.getAverageItemSize();\r\n    viewport.setTotalContentSize(totalSize);\r\n  }\r\n}\r\n\r\n/**\r\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\r\n * `AutoSizeVirtualScrollStrategy` from the given directive.\r\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\r\n *     `AutoSizeVirtualScrollStrategy` from.\r\n */\r\nexport function _autoSizeVirtualScrollStrategyFactory(autoSizeDir: CdkAutoSizeVirtualScroll) {\r\n  return autoSizeDir._scrollStrategy;\r\n}\r\n\r\n\r\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\r\n@Directive({\r\n  selector: 'cdk-virtual-scroll-viewport[autosize]',\r\n  providers: [{\r\n    provide: VIRTUAL_SCROLL_STRATEGY,\r\n    useFactory: _autoSizeVirtualScrollStrategyFactory,\r\n    deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\r\n  }],\r\n})\r\nexport class CdkAutoSizeVirtualScroll implements OnChanges {\r\n  /**\r\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\r\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\r\n   */\r\n  @Input()\r\n  get minBufferPx(): number { return this._minBufferPx; }\r\n  set minBufferPx(value: number) { this._minBufferPx = coerceNumberProperty(value); }\r\n  _minBufferPx = 100;\r\n\r\n  /**\r\n   * The number of pixels worth of buffer to shoot for when rendering new items.\r\n   * If the actual amount turns out to be less it will not necessarily trigger an additional\r\n   * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\r\n   * Defaults to 200px.\r\n   */\r\n  @Input()\r\n  get maxBufferPx(): number { return this._maxBufferPx; }\r\n  set maxBufferPx(value: number) { this._maxBufferPx = coerceNumberProperty(value); }\r\n  _maxBufferPx = 200;\r\n\r\n  /** The scroll strategy used by this directive. */\r\n  _scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\r\n\r\n  ngOnChanges() {\r\n    this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {NgModule} from '@angular/core';\r\nimport {CdkAutoSizeVirtualScroll} from './auto-size-virtual-scroll';\r\n\r\n\r\n@NgModule({\r\n  exports: [CdkAutoSizeVirtualScroll],\r\n  declarations: [CdkAutoSizeVirtualScroll],\r\n})\r\nexport class ScrollingModule {}\r\n"],"names":["_autoSizeVirtualScrollStrategyFactory","autoSizeDir","_scrollStrategy","ItemSizeAverager","defaultItemSize","this","_totalWeight","_defaultItemSize","_averageItemSize","prototype","getAverageItemSize","addSample","range","size","newTotalWeight","end","start","newAverageItemSize","reset","AutoSizeVirtualScrollStrategy","minBufferPx","maxBufferPx","averager","scrolledIndexChange","Observable","create","Error","_viewport","_removalFailures","_minBufferPx","_maxBufferPx","_averager","attach","viewport","_setScrollOffset","detach","onContentScrolled","_updateRenderedContentAfterScroll","onDataLengthChanged","_checkRenderedContentSize","onContentRendered","onRenderedOffsetChanged","_checkRenderedContentOffset","scrollToIndex","updateBufferSize","scrollOffset","measureScrollOffset","scrollDelta","_lastScrollOffset","scrollMagnitude","Math","abs","renderedRange","getRenderedRange","offsetCorrection","predictedOffset","offsetDifference","_lastRenderedContentOffset","round","max","min","startBuffer","endBuffer","_lastRenderedContentSize","getViewportSize","underscan","addItems","ceil","overscan","unboundedRemoveItems","floor","removeItems","_expandRange","contentOffset","contentOffsetTo","removedSize","measureRangeSize","setRenderedRange","setRenderedContentOffset","measureRenderedContentSize","_updateTotalContentSize","getOffsetToRenderedContentStart","setScrollOffset","itemSize","firstVisibleIndex","getDataLength","bufferSize","_getVisibleRangeForIndex","startIndex","extra","expandStart","expandEnd","renderedContentSize","totalSize","setTotalContentSize","Object","defineProperty","CdkAutoSizeVirtualScroll","value","coerceNumberProperty","ngOnChanges","type","Directive","args","selector","providers","provide","VIRTUAL_SCROLL_STRATEGY","useFactory","deps","forwardRef","Input","NgModule","exports","declarations","ScrollingModule"],"mappings":"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"}